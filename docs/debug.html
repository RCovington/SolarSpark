<title>SolarSpark</title>
<meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1.01'>
<style>
    #t{
    display: table;
}

#c{
    display: table-cell;
    vertical-align: middle;
}

#cc{
    margin: auto;
    outline: 1px solid white;
}

body, html, #t, canvas{
    width: 100%;
    height: 100%;
    background-color: #000;
    margin: 0;

    -webkit-touch-callout: none;
    user-select: none;
    -webkit-user-select: none;
}

canvas{
    display: block;
    cursor: none;
}

</style>

<div id="t">
    <div id="c">
        <div id="cc">
            <canvas></canvas>
        </div>
    </div>
</div>

<script>
    
// Global utility functions
function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function rnd(min, max) { return Math.random() * (max - min) + min; }
function limit(min, val, max) { return Math.max(min, Math.min(val, max)); }
function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }
function distP(x1, y1, x2, y2) { return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2); }
function angleBetween(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function cos(a) { return Math.cos(a); }
function sin(a) { return Math.sin(a); }
function atan2(y, x) { return Math.atan2(y, x); }
function abs(x) { return Math.abs(x); }
function min(a, b) { return Math.min(a, b); }
function max(a, b) { return Math.max(a, b); }
function sign(x) { return Math.sign(x); }
function random() { return Math.random(); }
function normalize(angle) { while (angle > Math.PI) angle -= 2 * Math.PI; while (angle < -Math.PI) angle += 2 * Math.PI; return angle; }
function moduloWithNegative(a, b) { return ((a % b) + b) % b; }

// Math constants
let PI = Math.PI;
let TWO_PI = Math.PI * 2;
function nomangle(x) { return x; }
let CARGO_DATA = [
    { "cargo": "SynthMeat Blocks", "value": 5, "id": 1, "storage_units": 6, "category": "Foodstuffs", "description": "Factory-grown protein rations for long-haul freighters." },
    { "cargo": "Fuel Slush", "value": 5, "id": 2, "storage_units": 9, "category": "Raw Materials", "description": "Semi-frozen propellant for long-range starships." },
    { "cargo": "Terraform Clay", "value": 10, "id": 3, "storage_units": 10, "category": "Raw Materials", "description": "Soil matrix that reshapes barren terrain into fertile land." },
    { "cargo": "RadSpice", "value": 10, "id": 4, "storage_units": 3, "category": "Foodstuffs", "description": "Irradiated culinary additive prized on frontier worlds." },
    { "cargo": "Biofoam Packs", "value": 13, "id": 5, "storage_units": 2, "category": "Tech Goods", "description": "Emergency medical foam that seals wounds instantly." },
    { "cargo": "Data Slates", "value": 17, "id": 6, "storage_units": 1, "category": "Tech Goods", "description": "Encrypted information drives containing trade secrets." },
    { "cargo": "Circuit Dust", "value": 21, "id": 7, "storage_units": 2, "category": "Raw Materials", "description": "Micro-shards of superconductive alloys for advanced electronics." },
    { "cargo": "Solar Sails", "value": 28, "id": 8, "storage_units": 9, "category": "Tech Goods", "description": "Foldable energy-collecting sails for light-driven craft." },
    { "cargo": "Aether Gas", "value": 34, "id": 9, "storage_units": 6, "category": "Raw Materials", "description": "Rare luminescent vapor harvested from nebulae, used in energy cells." },
    { "cargo": "Cryonite", "value": 45, "id": 10, "storage_units": 4, "category": "Raw Materials", "description": "Super-cold mineral used in cooling drives and weapons." },
    { "cargo": "Plasma Coils", "value": 50, "id": 11, "storage_units": 5, "category": "Tech Goods", "description": "Energy storage units critical for starship weapons and reactors." },
    { "cargo": "Quantum Grain", "value": 50, "id": 12, "storage_units": 5, "category": "Foodstuffs", "description": "Engineered food supply that reshapes molecules for nutrition." },
    { "cargo": "Grav Cages", "value": 55, "id": 13, "storage_units": 8, "category": "Tech Goods", "description": "Containers that hold volatile materials in artificial gravity fields." },
    { "cargo": "Helix Seeds", "value": 77, "id": 14, "storage_units": 3, "category": "Foodstuffs", "description": "Genetically coded seeds for terraforming barren worlds." },
    { "cargo": "Neurogel", "value": 89, "id": 15, "storage_units": 3, "category": "Tech Goods", "description": "A biotech fluid used in neural interfaces and cybernetic repairs." },
    { "cargo": "CryoPods", "value": 100, "id": 16, "storage_units": 8, "category": "Tech Goods", "description": "Suspended-animation units for transporting passengers or livestock." },
    { "cargo": "Phantom Cloth", "value": 100, "id": 17, "storage_units": 2, "category": "Luxury", "description": "Adaptive camouflage fabric prized by smugglers." },
    { "cargo": "Nanoforge Kits", "value": 117, "id": 18, "storage_units": 7, "category": "Tech Goods", "description": "Portable matter printers used for colony construction." },
    { "cargo": "Skywine", "value": 144, "id": 19, "storage_units": 2, "category": "Luxury", "description": "Luxury beverage fermented in orbital vineyards." },
    { "cargo": "Stellar Ore", "value": 189, "id": 20, "storage_units": 5, "category": "Raw Materials", "description": "High-density mineral fragments harvested from neutron-star debris." },
    { "cargo": "Echo Stones", "value": 233, "id": 21, "storage_units": 2, "category": "Luxury", "description": "Resonant crystals used in alien communication tech." },
    { "cargo": "Flux Rods", "value": 305, "id": 22, "storage_units": 4, "category": "Contraband", "description": "Stabilizers for reactors, illegal without permits." },
    { "cargo": "Ion Crystals", "value": 377, "id": 23, "storage_units": 2, "category": "Raw Materials", "description": "Shards that stabilize energy flows in jump drives." },
    { "cargo": "VoidSilk", "value": 494, "id": 24, "storage_units": 2, "category": "Luxury", "description": "An ultralight fabric woven from nanofibers grown in zero-G." },
    { "cargo": "PsiCrystals", "value": 610, "id": 25, "storage_units": 2, "category": "Contraband", "description": "Rare minerals thought to enhance psionic abilities." },
    { "cargo": "CryoSpice", "value": 799, "id": 26, "storage_units": 2, "category": "Contraband", "description": "A rare crystalline compound used as both fuel additive and narcotic." },
    { "cargo": "Neurochips", "value": 987, "id": 27, "storage_units": 1, "category": "Contraband", "description": "Illicit brain-boosting implants banned in core systems." },
    { "cargo": "ChronoSerum", "value": 1292, "id": 28, "storage_units": 1, "category": "Contraband", "description": "A liquid compound rumored to slow cellular aging." },
    { "cargo": "Gravium", "value": 1597, "id": 29, "storage_units": 3, "category": "Raw Materials", "description": "A dense element that bends local gravity fields." },
    { "cargo": "Darkmatter Vials", "value": 2000, "id": 30, "storage_units": 1, "category": "Raw Materials", "description": "Experimental samples of compressed dark matter for research." }
  ]
  
let R, // canvas context
    G, // Game instance
    V, // Camera instance
    U, // Universe instance
    w = window,
    isTouch,
    mobile = navigator.userAgent.match(/andro|ipho|ipa|ipo|windows ph/i),
    CANVAS_HEIGHT = 1000,
    monoFont;

let dismiss = 'Dismiss';

limit = (a, b, c) => {
    if (b < a) return a;
    if (b > c) return c;
    return b;
};

between = (a, b, c) => {
    return b >= a && b <= c;
};

rnd = (min, max) => {
    return random() * (max - min) + min;
};

pick = a => {
    return a[~~(random() * a.length)];
};

distP = (x1, y1, x2, y2) => {
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
};

dist = (a, b) => {
    return distP(a.x, a.y, b.x, b.y);
};

sign = x => {
    return x < 0 ? -1 : (x > 0 ? 1 : 0);
};

// Modulo centered around zero: the result will be between -y and +y
moduloWithNegative = (x, y) => {
    x = x % (y * 2);
    if (x > y) {
        x -= y * 2;
    }
    if (x < -y) {
        x += y * 2;
    }
    return x;
};

normalize = x => {
    // Possibly faster version but definitely smaller
    return moduloWithNegative(x, PI);
    // while (x < -PI) x += TWO_PI;
    // while (x > PI) x -= TWO_PI;
    // return x;
};

angleBetween = (a, b) => {
    return atan2(b.y - a.y, b.x - a.x);
};

// Make Math global
let m = Math;
Object.getOwnPropertyNames(m).forEach(n => w[n] = w[n] || m[n]);

TWO_PI = PI * 2;

let p = CanvasRenderingContext2D.prototype;

// A couple extra canvas functions
p.wrap = function(f) {
    this.save();
    f();
    this.restore();
};
p.fr = p.fillRect;
p.fs = function(x) { this.fillStyle = x };

stickString = string => {
    let absoluteSegments = [];

    let characterX = 0;
    let width;
    string.toLowerCase().split('').forEach(character => {
        let charSegments = characterSettings[character] || [];

        let nextX = characterX;
        charSegments.forEach(segment => {
            absoluteSegments.push([
                characterX + segment[0],
                segment[1],
                characterX + segment[2],
                segment[3]
            ]);
            nextX = max(nextX, characterX + segment[0] + 1.0, characterX + segment[2] + 1.0);
        });

        if (!charSegments.length) {
            nextX += 1.5;
        }

        characterX = nextX + 0.1;
        width = characterX - 2 / 5;
    });

    let appearanceOffsets = [];
    absoluteSegments.forEach((x, offset) => {
        appearanceOffsets.splice(~~(random() * appearanceOffsets.length), 0, offset);
    });

    return {
        'segments': absoluteSegments,
        'appearanceOffsets': appearanceOffsets,
        'width': width
    };
};

renderStickString = (stickStringSettings, charWidth, charHeight, progress, segmentInterval, appearanceTime) => {
    stickStringSettings.segments.forEach((segment, index) => {
        wrap(() => {
            let appearanceOffset = stickStringSettings.appearanceOffsets[index];
            let delay = appearanceOffset * segmentInterval;
            let factor = limit(0, (progress - delay) / appearanceTime, 1);

            let direction = sign(((index + appearanceOffset) % 2) - 0.5);
            if (((index % 2) - 0.5) > 0) {
                translate(direction * (1 - factor) * 50, 0);
            } else {
                translate(0, direction * (1 - factor) * 50);
            }

            R.globalAlpha *= factor;

            beginPath();
            moveTo(segment[0] * charWidth, segment[1] * charHeight);
            lineTo(segment[2] * charWidth, segment[3] * charHeight);
            stroke();
        });
    });
}

let leftSegment = [0, 0, 0, 1];
let rightSegment = [1, 0, 1, 1];
let topSegment = [0, 0, 1, 0];
let bottomSegment = [0, 1, 1, 1];
let middleHorizontalSegment = [0, 1 / 2, 1, 1 / 2];
let rightBottomSegment = [1, 1 / 2, 1, 1];

let characterSettings = {
    'a': [
        [0, 1, 1 / 2, 0],
        [1, 1, 1 / 2, 0]
    ],
    'b': [
        leftSegment,
        bottomSegment,
        middleHorizontalSegment,
        rightBottomSegment,
        [0, 0, 3 / 4, 0],
        [3 / 4, 0, 3 / 4, 1 / 2]
    ],
    'c': [
        leftSegment,
        topSegment,
        bottomSegment
    ],
    'd': [
        leftSegment,
        [0, 0, 1, 1 / 2],
        [1, 1 / 2, 0, 1]
    ],
    'e': [
        leftSegment,
        topSegment,
        [0, 1 / 2, 1 * 2 / 3, 1 / 2],
        bottomSegment
    ],
    'f': [
        leftSegment,
        topSegment,
        [0, 1 / 2, 1 * 2 / 3, 1 / 2]
    ],
    'g': [
        topSegment,
        leftSegment,
        bottomSegment,
        rightBottomSegment
    ],
    'h': [
        leftSegment,
        rightSegment,
        middleHorizontalSegment
    ],
    'i': [
        leftSegment
    ],
    'j': [
        rightSegment,
        bottomSegment,
        [0, 1 / 2, 0, 1]
    ],
    'k': [
        leftSegment,
        [1, 0, 0, 1 / 2],
        [1, 1, 0, 1 / 2],
    ],
    'l': [
        leftSegment,
        bottomSegment
    ],
    'm': [
        leftSegment,
        [0, 0, 1 / 2, 1 / 2],
        [1, 0, 1 / 2, 1 / 2],
        rightSegment
    ],
    'n': [
        leftSegment,
        [0, 0, 1, 1],
        rightSegment
    ],
    'o': [
        topSegment,
        bottomSegment,
        leftSegment,
        rightSegment
    ],
    'p': [
        leftSegment,
        topSegment,
        [1, 0, 1, 1 / 2],
        middleHorizontalSegment,
    ],
    'q': [
        topSegment,
        bottomSegment,
        leftSegment,
        rightSegment,
        [1, 1, 1, 1.3]
    ],
    'r': [
        leftSegment,
        topSegment,
        [1, 0, 1, 1 / 2],
        middleHorizontalSegment,
        [0, 1 / 2, 1, 1]
    ],
    's': [
        topSegment,
        [0, 0, 0, 1 / 2],
        middleHorizontalSegment,
        rightBottomSegment,
        bottomSegment,
    ],
    't': [
        topSegment,
        [1 / 2, 0, 1 / 2, 1]
    ],
    'u': [
        leftSegment,
        bottomSegment,
        rightSegment
    ],
    'v': [
        [0, 0, 1 / 2, 1],
        [1, 0, 1 / 2, 1]
    ],
    'w': [
        [0, 0, 1 / 4, 1],
        [1 / 4, 1, 1 / 2, 1 / 2],
        [3 / 4, 1, 1 / 2, 1 / 2],
        [1, 0, 3 / 4, 1],
    ],
    'x': [
        [0, 0, 1, 1],
        [1, 0, 0, 1]
    ],
    'y': [
        [0, 0, 1 / 2, 1 / 2],
        [1 / 2, 1 / 2, 1, 0],
        [1 / 2, 1 / 2, 1 / 2, 1]
    ],
    'z': [
        topSegment,
        bottomSegment,
        [1, 0, 0, 1]
    ],
    '\'': [
        [0, 1 / 4, 1 / 4, 0]
    ],
    '-': [
        [0, 1 / 2, 1, 1 / 2]
    ]
};

let createCanvas = (w, h, instructions) => {
    let can = document.createElement('canvas');
    can.width = w;
    can.height = h;

    let ctx = can.getContext('2d');

    instructions(ctx, can);

    return can;
};

renderResourcesIcon = () => {
    beginPath(); arc(0, -12, 15, 0, TWO_PI); fill();
    beginPath(); arc(12, 12, 15, 0, TWO_PI); fill();
    beginPath(); arc(-12, 12, 15, 0, TWO_PI); fill();
};

haloAround = (asset, haloRadius, colorStart, colorEnd) => {
    return createCanvas(asset.width + haloRadius * 2, asset.height + haloRadius * 2, (r, can) => {
        let gradient = r.createRadialGradient(can.width / 2, can.height / 2, asset.width / 2, can.width / 2, can.height / 2, asset.width / 2 + haloRadius);
        gradient.addColorStop(0, colorStart);
        gradient.addColorStop(1, colorEnd);

        r.fs(gradient);
        r.fr(0, 0, can.width, can.height);

        try { r.drawImage(asset, haloRadius, haloRadius); } catch(e) {}
    });
};

particle = (color, interpolations, render) => {
    let p;

    // Add to the list of particles
    U.particles.push(p = {
        color: color,
        alpha: 1,
        render: () => wrap(() => {
            if (render) {
                // if (true) {
                //     G.renderedParticles++;
                // }
                return render(p);
            }

            if (!V.isVisible(p, p.size)) {
                return;
            }

            // if (true) {
            //     G.renderedParticles++;
            // }

            R.globalAlpha = p.alpha;
            fs(p.color);
            beginPath();
            arc(p.x, p.y, p.size / 2, 0, TWO_PI);
            fill();
            // fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        })
    });

    // Interpolations
    interpolations.forEach((a, id) => {
        let args = [p].concat(a);

        // Add the remove callback to the first interpolation
        if (!id) {
            args[7] = () => U.remove(U.particles, p);
        }

        // Apply the interpolation
        interp.apply(0, args);
    });
};

class MissionStep {

    constructor() {
        this.listeners = [];
    }

    attach() {
        // To be overridden
    }

    detach() {
        // Stop listening to all events
        this.listeners.forEach(listener => G.eventHub.ignore(listener.event, listener.listener));
        this.listeners = [];
    }

    listen(event, listener) {
        this.listeners.push({'event': event, 'listener': listener});
        G.eventHub.listen(event, listener);
    }

    start() {
        this.attach();
    }

    proceed(nextStep) {
        this.proceedListener(nextStep);
    }

}

class PromptTutorialStep extends MissionStep {

    attach() {
        V.targetScaleOverride = 1;

        G.showPrompt('Follow a quick tutorial?', [{
            'label': 'Yes',
            'action': () => this.proceed(new MovementStep())
        }, {
            'label': 'No',
            'action': () => this.proceed(new InstructionsStep())
        }]);
    }

}

class MovementStep extends MissionStep {

    attach() {
        G.showPrompt('Use arrow keys to control your ship');

        let start = {'x': U.playerShip.x, 'y': U.playerShip.y};
        this.listen(1, () => {
            if (dist(start, U.playerShip) > 500) {
                this.proceed(new ShootingStep());
            }
        });
    }

}

class ShootingStep extends MissionStep {

    attach() {
        G.showPrompt('Press [SPACE] for blasters, [ENTER] for torpedoes');

        let shots = 20;
        this.listen(2, projectile => {
            if (projectile.owner === U.playerShip && !--shots) {
                this.proceed(new OfflineStep());
            }
        });
    }

}

class OfflineStep extends MissionStep {

    attach() {
        G.showPrompt('Communications OFFLINE. Find resources to repair', [{
            'label': 'Help',
            'action': () => G.showPrompt('Resources can be collected by destroying asteroids')
        }]);

        this.listen(1, () => {
            if (U.playerShip.civilization.resources >= 20) {
                this.proceed(new TutorialFinishedStep());
            }

            if (U.bodies.length < 10) {
                U.randomAsteroid();
            }
        });
    }

}

class TutorialFinishedStep extends MissionStep {
    attach() {
        G.showPrompt('Communications ONLINE. Good job');

        setTimeout(() => this.proceed(new InstructionsStep()), 5000);
    }
}

class InstructionsStep extends MissionStep {
    attach() {
        V.targetScaleOverride = 0;

        U.generateUniverse();

        G.showPrompt('Bring PEACE to the galaxy, or WAR...', [{
            'label': dismiss,
            'action': () => this.proceed()
        }]);

        G.nextMission = 0;
    }
}

class PromptMission extends MissionStep {

    constructor(missionStep) {
        super();
        this.missionStep = missionStep;
    }

    attach() {
        super.attach();

        let timeleft = 15;
        this.listen(1, e => {
            if ((timeleft -= e) < 0) {
                this.proceed();
            }
        });

        G.showPrompt(() => 'Incoming communication from ' + this.missionStep.civilization.center.nameWithRelationship() + ' - ' + formatTime(timeleft), [{
            'label': 'Respond',
            'action': () => {
                timeleft = 15;
                G.showPrompt(() => this.missionStep.prompt + ' - ' + formatTime(timeleft), [{
                    'label': 'Accept',
                    'action': () => this.proceed(this.missionStep)
                }, {
                    'label': 'Refuse',
                    'action': () => this.proceed()
                }]);
            }
        }, {
            'label': 'Ignore',
            'action': () => this.proceed()
        }]);
    }

    proceed(missionStep) {
        super.proceed(missionStep);

        // If a missionStep was provided it means the player accepted the mission.
        // Clear any offer state on the planet so the offer disappears immediately.
        if (missionStep) {
            try {
                let planet = missionStep.civilization && missionStep.civilization.center;
                if (planet) {
                    planet.hasOffer = 0;
                    planet.offerExpires = null;
                }
            } catch (e) {
                // defensive: don't break the mission flow if something unexpected is shaped
                console.error('Error clearing planet offer on accept', e);
            }
        }

        if (!missionStep) {
            // Penalize reputation for ignoring an incoming communication
            try {
                if (this.missionStep && this.missionStep.civilization && typeof this.missionStep.civilization.reputation === 'number') {
                    this.missionStep.civilization.reputation -= 100;
                    if (typeof this.missionStep.civilization.applyReputationToRelationship === 'function') {
                        this.missionStep.civilization.applyReputationToRelationship();
                    }
                }
            } catch (e) {}

            this.missionStep.civilization.updateRelationship(-0.1);
            try { if (typeof U !== 'undefined' && typeof U.saveState === 'function') U.saveState(); } catch (e) {}
            G.showPrompt('Communication ignored. ' + this.missionStep.civilization.center.name + ' will remember that', [{
                'label': dismiss,
                'action': () => G.showPrompt()
            }]);
            setTimeout(() => G.showPrompt(), 5000);
        }
    }

}

class TimedMissionStep extends MissionStep {

    attach() {
        this.timeleft = 120;
        this.listen(1, e => {
            if ((this.timeleft -= e) < 0) {
                G.missionDone(0);
            }
        });

        // Create a stable prompt function so we can re-assert it if other systems overwrite/clear prompts.
        // We only re-assert when necessary (i.e. when another caller changed the prompt), to avoid
        // continuously resetting the prompt clock which drives the typewriter effect.
        this._missionPromptFunc = () => this.instructions() + ' - ' + formatTime(this.timeleft);
        G.showPrompt(this._missionPromptFunc);

        // Defensive: if some other system overwrites or clears the prompt while this mission is active,
        // re-assert our mission prompt on the next cycle. The listener is registered via this.listen so
        // it will be removed automatically when the mission detaches.
        this.listen(1, () => {
            try {
                if (G.missionStep !== this) return;
                if (G.promptText !== this._missionPromptFunc) {
                    G.showPrompt(this._missionPromptFunc);
                }
            } catch (e) { /* ignore */ }
        });
    }

    reach(target, prompt) {
        let step = new ReachTarget(target, prompt);
        step.civilization = this.civilization;
        this.proceed(step);

        step.timeleft = this.timeleft;
    }

}

class AttackPlanet extends TimedMissionStep {

    constructor(planet) {
        super();
        this.planet = planet;
        this.prompt = 'Destroy facilities on ' + planet.nameWithRelationship();
        this.targets = [planet];

        this.destroyedStations = 0;
        this.stationsToDestroy = min(this.planet.stations.length, ~~rnd(3, 5));
    }

    instructions() {
        return 'Facilities destroyed: ' + this.destroyedStations + '/' + this.stationsToDestroy;
    }

    attach() {
        super.attach();

        this.listen(0, station => {
            if (station.planet === this.planet) {
                this.destroyedStations++;
                if (this.destroyedStations >= this.stationsToDestroy) {
                    G.missionDone(1);
                }
            }
        });
    }

}

class StudyBody extends TimedMissionStep {

    constructor(body) {
        super();
        this.body = body;
        this.prompt = 'Collect some data on ' + body.nameWithRelationship() + ' for us';
        this.targets = [body];

        this.studied = 0;
    }

    instructions() {
        if (this.isClose()) {
            return 'Collecting data... - ' + ~~(this.studied * 100) + '%';
        }
        return 'Get close to ' + this.body.name;
    }

    attach() {
        super.attach();

        this.listen(1, e => {
            if (this.isClose()) {
                this.studied += e * (1 / 40);

                if (this.studied >= 1) {
                    this.reach(this.civilization.center, 'Return to ' + this.civilization.center.name);
                }
            }
        });
    }

    isClose() {
        return dist(U.playerShip, this.body) < this.body.radius * 4;
    }

}

class CollectResources extends TimedMissionStep {

    constructor() {
        super();

        this.prompt = 'Collect some resources for us';

        this.requiredResources = 100;
        this.collectedResources = 0;
    }

    instructions() {
        return 'Collect resources - ' + this.collectedResources + '/' + this.requiredResources;
    }

    attach() {
        super.attach();

        this.listen(3, () => {
            U.playerShip.civilization.resources--; // make sure the player doesn't get these resources

            if (++this.collectedResources >= this.requiredResources) {
                this.reach(this.civilization.center, 'Return to ' + this.civilization.center.name);
            }
        });
    }

}

class Asteroids extends TimedMissionStep {

    constructor() {
        super();
        this.prompt = 'Destroy these asteroids for us';
    }

    instructions() {
        return 'Destroy the asteroids';
    }

    attach() {
        super.attach();

        let asteroids = [];
        for (let i = 0 ; i < 5 ; i++) {
            let asteroid = new Asteroid();
            asteroid.x = U.playerShip.x + pick([-1, 1]) * 1000 / 0.25;
            asteroid.y = U.playerShip.y + rnd(-1, 1) * CANVAS_HEIGHT * 2;
            asteroid.vX = sign(U.playerShip.x - asteroid.x) * min(abs(asteroid.vX), 100);
            asteroid.vY = sign(U.playerShip.y - asteroid.y) * min(abs(asteroid.vY), 100);
            asteroid.preventAutomaticRemoval = 1;
            U.bodies.push(asteroid);

            asteroids.push(asteroid);
        }

        this.listen(1, () => {
            this.targets = asteroids.filter(asteroid => asteroid.health > 0);

            if (!this.targets.length) {
                G.missionDone(1);
            }
        });
    }

}

class Pirates extends TimedMissionStep {

    constructor() {
        super();
        this.prompt = 'Help us fight these pirates';
    }

    instructions() {
        return 'Destroy the pirate ships';
    }

    attach() {
        super.attach();

        let pirates = U.createPirateGroup(
            this.civilization.center.orbitsAround.x + pick([-1, 1]) * (this.civilization.center.orbitsAround.reachRadius + 2000),
            this.civilization.center.y + rnd(-2000, 2000)
        );

        this.listen(1, () => {
            this.targets = pirates.filter(ship => ship.health > 0);

            if (!this.targets.length) {
                G.missionDone(1);
            }
        });
    }

}

class ReachTarget extends TimedMissionStep {

    constructor(target, prompt) {
        super();
        this.targets = [target];
        this.prompt = prompt;
    }

    instructions() {
        return this.prompt;
    }

    attach() {
        super.attach();

        this.listen(1, () => {
            if (dist(this.targets[0], U.playerShip) < this.targets[0].radius * 3) {
                G.missionDone(1);
            }
        });
    }

}

class Universe {

    constructor() {
        this.ships = [];
        this.bodies = [];
        this.stars = [];
        this.particles = [];
        this.projectiles = [];
        this.items = [];
        this.pirates = [];

        this.center = {'x': 0, 'y': 0};

        this.backgroundStarGradient = createRadialGradient(0, 0, 0, 0, 0, 1);
        this.backgroundStarGradient.addColorStop(0, 'rgba(255,255,200,1)');
        this.backgroundStarGradient.addColorStop(0.3, 'rgba(255,255,200,0.1)');
        this.backgroundStarGradient.addColorStop(1, 'rgba(255,255,200,0)');

        this.createPlayerShip();

        // setTimeout(() => this.generateUniverse(), 0);
        this.nextAsteroid = 0;
        this.orbitalStations = [];
        this.offerRefreshTimer = 0;
    }

    createPlayerShip() {
        this.remove(this.ships, this.playerShip);
        this.ships.push(this.playerShip = new PlayerShip(this.center.x, this.center.y));
        // New ship should start with zero credits and empty cargo by default. If restoreState
        // later populates upgrades/baseStats they'll be applied, but credits/cargo are reset
        // on creation (so they are lost on destruction/respawn as requested).
        try { this.playerShip.credits = 0; } catch (e) {}
        try { this.playerShip.cargo = {}; } catch (e) {}
    // Ensure a sensible default cargo capacity so upgrades apply relative to a real base
    try { if (typeof this.playerShip.cargoCapacity !== 'number' || this.playerShip.cargoCapacity <= 0) this.playerShip.cargoCapacity = 200; } catch (e) {}

        // Wrap credits and cargoCapacity with property accessors so UI can listen for changes
        try {
            let ship = this.playerShip;
            // Credits
            try {
                ship._credits = ship._credits || (ship.credits || 0);
                Object.defineProperty(ship, 'credits', {
                    configurable: 1,
                    enumerable: 1,
                    get: function() { return this._credits; },
                    set: function(v) {
                        let old = this._credits;
                        this._credits = v;
                        try {
                            if (typeof G !== 'undefined' && G && G.eventHub && old !== v) {
                                G.eventHub.emit('player:creditsChanged', v);
                            }
                        } catch (e) {}
                    }
                });
            } catch (e) {}

            // cargoCapacity
            try {
                ship._cargoCapacity = ship._cargoCapacity || (ship.cargoCapacity || 0);
                Object.defineProperty(ship, 'cargoCapacity', {
                    configurable: 1,
                    enumerable: 1,
                    get: function() { return this._cargoCapacity; },
                    set: function(v) {
                        let old = this._cargoCapacity;
                        this._cargoCapacity = v;
                        try {
                            if (typeof G !== 'undefined' && G && G.eventHub && old !== v) {
                                G.eventHub.emit('player:cargoCapacityChanged', v);
                            }
                        } catch (e) {}
                    }
                });
            } catch (e) {}
        } catch (e) {}
    }

    cycle(e) {
        if ((this.nextAsteroid -= e) <= 0) {
            this.nextAsteroid = 3;
            this.randomAsteroid();
        }


        // Remove expired offers first
        try {
            let planetsForExpiry = this.bodies.filter(b => b instanceof Planet && b.hasOffer && b.offerExpires);
            planetsForExpiry.forEach(p => {
                if (typeof G !== 'undefined' && G.clock >= p.offerExpires) {
                    p.hasOffer = 0;
                    p.offerExpires = null;
                }
            });
        } catch (e) { /* ignore */ }

        // Periodically generate new offers (~every 10 minutes)
        if ((this.offerRefreshTimer -= e) <= 0) {
            this.offerRefreshTimer = 600; // 600s = 10 minutes
            this.refreshOffers();
        }

        this.forEach([this.bodies, this.ships, this.items, this.projectiles, [V]], element => element.cycle(e));
    }

    refreshOffers() {
        try {
            let planets = this.bodies.filter(b => b instanceof Planet);
            if (!planets.length) return;

            // Number of offers to generate on this refresh (approx 1/3 of planets)
            let count = Math.max(1, Math.floor(planets.length / 3));

            // Only assign offers to planets that don't already have one
            let available = planets.filter(p => !p.hasOffer);
            if (!available.length) return;

            // Shuffle available planets
            let idx = available.map((_, i) => i);
            for (let i = idx.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                let t = idx[i]; idx[i] = idx[j]; idx[j] = t;
            }

            let now = (typeof G !== 'undefined' && G.clock) ? G.clock : 0;
            for (let k = 0; k < Math.min(count, idx.length); k++) {
                let p = available[idx[k]];
                p.hasOffer = 1;
                // Offer persists for 10 minutes (600s)
                p.offerExpires = now + 600;
            }
        } catch (e) { /* ignore */ }
    }

    randomAsteroid() {
        let asteroid = new Asteroid();
        asteroid.x = U.playerShip.x + pick([-1.1, 1.1]) * V.visibleWidth / 2;
        asteroid.y = U.playerShip.y + pick([-1.1, 1.1]) * V.visibleHeight / 2;
        U.bodies.push(asteroid);
    }

    forEach(arrays, func) {
        arrays.forEach(x => x.forEach(y => func(y)));
    }

    render() {
        fs('#000');
        fr(0, 0, 1000, CANVAS_HEIGHT);

        let rng = createNumberGenerator(1);

        wrap(() => {
            translate(1000 / 2, CANVAS_HEIGHT / 2);
            scale(V.zoomScale, V.zoomScale);

            fs(this.backgroundStarGradient);

            for (let i = 0 ; i < 400 ; i++) {
                wrap(() => {
                    let distanceFactor = rng.between(0.1, 0.3);
                    translate(
                        moduloWithNegative(rng.between(-1, 1) * 1000 - U.playerShip.x * distanceFactor, 1000),
                        moduloWithNegative(rng.between(-1, 1) * CANVAS_HEIGHT - U.playerShip.y * distanceFactor, CANVAS_HEIGHT)
                    );

                    scale(distanceFactor * 20, distanceFactor * 20);

                    beginPath();
                    arc(
                        0,
                        0,
                        1,
                        0,
                        TWO_PI
                    );
                    fill();
                });
            }
        });

        wrap(() => {
            scale(V.zoomScale, V.zoomScale);
            translate(-V.x, -V.y);

            this.forEach([this.projectiles, this.particles, this.ships, this.bodies, this.items], element => wrap(() => {
                element.render();
            }));
        });
    }

    remove(array, item) {
        let index = array.indexOf(item);
        if (index >= 0) {
            array.splice(index, 1);
        }
    }

    forEachTarget(fn) {
        this.forEach([this.ships, this.bodies], fn);
        this.bodies.forEach(p => (p.stations || []).forEach(fn));
    }

    generateUniverse() {
        this.center = {
            'x': U.playerShip.x,
            'y': U.playerShip.y
        };

        let maxSystemRadius = 4 * 700 + 4000;

        let rng = createNumberGenerator(1);

        for (let i = 0 ; i < 3 ; i++) {
            let radius = i * maxSystemRadius;
            let phase = rng.between(0, TWO_PI);

            let maxSystems = ~~(TWO_PI * radius / maxSystemRadius); // using the circumference leads to slightly incorrect margins, but whatever

            for (let i = 0 ; i < maxSystems ; i++) {
                let angle = (i / maxSystems) * TWO_PI;

                // Generate a system there
                let star = new Star(rng);
                star.x = cos(angle + phase) * radius + U.playerShip.x;
                star.y = sin(angle + phase) * radius + U.playerShip.y;
                this.bodies.push(star);
                this.stars.push(star);

                let planets = rng.between(2, 4);
                let orbitRadius = rng.between(500, 700);
                for (let j = 0 ; j < planets ; j++) {
                    let planet = new Planet(star, orbitRadius, rng.floating() * 999);
                    this.bodies.push(planet);

                    star.reachRadius = orbitRadius + planet.radius;

                    orbitRadius += rng.between(500, 700);
                }

                // Add outer orbital stations - closer spacing like planet rings


                const outerOrbitRadius = orbitRadius + rng.between(200, 300);


                for (let k = 0; k < 3; k++) {


                    const stationPhase = (k / 3) * 6.283185307179586 + rng.between(-0.2, 0.2);


                    const orbitalStation = new OrbitalStation(star, outerOrbitRadius, stationPhase);


                    this.orbitalStations.push(orbitalStation);


                    this.bodies.push(orbitalStation);


                }



                // Create some pirates
                let pirateAngle = rng.between(0, TWO_PI);
                this.createPirateGroup(
                    cos(pirateAngle) * (radius + maxSystemRadius / 2),
                    sin(pirateAngle) * (radius + maxSystemRadius / 2)
                );
            }
        }

        // After generating bodies, immediately seed offers so players see messages right away
        try {
            this.refreshOffers();
            // set the refresh timer so we don't immediately regenerate on the next cycle
            this.offerRefreshTimer = 600;
        } catch (e) { /* ignore */ }

        // Attempt to restore persisted world state (reputation, markets) if available
        try {
            if (typeof this.restoreState === 'function') this.restoreState();
        } catch (e) { /* ignore */ }
    }

    saveState() {
        try {
            let key = 'ss_save_v1';
            let payload = this.bodies.filter(b => b instanceof Planet).map(p => ({
                name: p.name,
                reputation: p.civilization && typeof p.civilization.reputation === 'number' ? p.civilization.reputation : undefined,
                market: p.market || null,
                prices: p.prices || null
            }));
            // Persist player ship upgrades and base stats
            try {
                let shipData = {};
                if (this.playerShip) {
                    shipData.upgrades = this.playerShip.upgrades || null;
                    shipData.baseStats = this.playerShip.baseStats || null;
                    shipData.credits = this.playerShip.credits || 0;
                }
                payload.push({__playerShip: shipData});
            } catch (e) { /* ignore */ }
            try { localStorage.setItem(key, JSON.stringify(payload)); } catch (e) { /* ignore */ }
        } catch (e) { /* ignore */ }
    }

    restoreState() {
        try {
            let key = 'ss_save_v1';
            let raw = null;
            try { raw = localStorage.getItem(key); } catch (e) { raw = null; }
            if (!raw) return;
            let payload = JSON.parse(raw);
            if (!Array.isArray(payload)) return;
            // match by planet name and restore simple fields
            payload.forEach(entry => {
                try {
                    let p = this.bodies.find(b => b instanceof Planet && b.name === entry.name);
                    if (!p) return;
                    if (entry.reputation !== undefined && p.civilization) {
                        p.civilization.reputation = entry.reputation;
                        if (typeof p.civilization.applyReputationToRelationship === 'function') p.civilization.applyReputationToRelationship();
                    }
                    if (entry.market) p.market = entry.market;
                    if (entry.prices) p.prices = entry.prices;
                } catch (e) { /* ignore per-entry */ }
            });
            // Try to find player ship data appended at the end
            try {
                let shipEntry = payload.find(e => e && e.__playerShip);
                if (shipEntry && this.playerShip) {
                    let sd = shipEntry.__playerShip;
                        // Only restore upgrades and baseStats for respawn persistence. Do NOT restore
                        // credits or cargo: those should be lost when a ship is destroyed.
                        if (sd.upgrades) this.playerShip.upgrades = sd.upgrades;
                        if (sd.baseStats) this.playerShip.baseStats = sd.baseStats;
                    // Reapply upgrades to ensure ship stats updated
                    if (typeof this.playerShip.upgrades !== 'undefined' && typeof this.playerShip.baseStats !== 'undefined') {
                        try {
                            if (typeof window !== 'undefined' && typeof window.applyShipUpgrades === 'function') {
                                try { window.applyShipUpgrades(this.playerShip); } catch (e) {}
                            }
                        } catch (e) {}
                    }
                }
            } catch (e) { /* ignore */ }
        } catch (e) { /* ignore */ }
    }

    // debugView() {
    //     let can = document.createElement('canvas');
    //     can.width = 500;
    //     can.height = 500;
    //
    //     let ctx = can.getContext('2d');
    //
    //     let furthestStar = this.stars.reduce((furthestStar, star) => {
    //         return max(furthestStar, dist(star, this.center));
    //     }, 0);
    //
    //     ctx.fs('#000');
    //     ctx.fr(0, 0, can.width, can.height);
    //
    //     this.bodies.concat(this.ships).forEach(body => {
    //         if (body instanceof Star) {
    //             ctx.fs('#ff0');
    //         }
    //
    //         if (body instanceof Planet) {
    //             ctx.fs('#00f');
    //         }
    //
    //         if (body instanceof Ship) {
    //             ctx.fs('#f00');
    //         }
    //
    //         let distance = dist(body, this.center);
    //         let angle = angleBetween(this.center, body);
    //         let relativeDistance = distance / furthestStar;
    //
    //         ctx.fr(
    //             can.width / 2 + cos(angle) * relativeDistance * can.width / 2,
    //             can.height / 2 + sin(angle) * relativeDistance * can.height / 2,
    //             5,
    //             5
    //         );
    //     });
    //
    //     document.body.appendChild(can);
    // }

    createPirateGroup(x, y) {
        let ships = [...Array(~~rnd(4, 6))].map(() => new AIShip(
            new Civilization({'x': x, 'y': y, 'radius': 300}, 0),
            x + rnd(-300, 300),
            y + rnd(-300, 300)
        ));

        this.ships = this.ships.concat(ships);
        this.pirates = this.pirates.concat(ships);

        return ships;
    }

    dropResources(x, y, n) {
        // Drop resources
        [...Array(~~n)].forEach(() => U.items.push(new ResourceItem(x, y)));
    }

    // randomAsteroidField(x, y) {
    //     for (let i = 0 ; i < 10 ; i++) {
    //         // let angle = random() * TWO_PI;
    //         // let dist = random() *
    //         let asteroid = new Asteroid(0, rnd(-10, 10));
    //         asteroid.preventAutomaticRemoval = 1;
    //         asteroid.x = x + rnd(-200, 200);
    //         asteroid.y = y + rnd(-200, 200);
    //         U.bodies.push(asteroid);
    //     }
    // }

}

class Body {

    constructor() {
        this.x = this.y = 0;
        this.radius = 0;
    }

    cycle() {
        U.ships.forEach(ship => {
            let minDist = this.radius + ship.radius;
            let overlap = minDist - dist(ship, this);
            if (overlap > 0) {
                // If the ship is docked (e.g. in planetary/station trade UI) skip collision handling
                // This prevents repeated explosion/crash sounds while the player is docked.
                try {
                    if (ship.isDocked || ship.inTradingInterface) return;
                } catch (e) {}
                // Push the ship away
                let angle = angleBetween(this, ship);
                ship.x = this.x + cos(angle) * (minDist + 5);
                ship.y = this.y + sin(angle) * (minDist + 5);
                ship.vX += cos(angle) * (overlap + 50 * 2);
                ship.vY += sin(angle) * (overlap + 50 * 2);

                interp(ship, 'uncontrolledRotation', pick([-6, 6]), 0, 1);

                ship.damage(this, 0.1);

                if (V.isVisible(ship)) {
                    explosionSound();
                }
            }
        });
    }

    // For reference only
    // render() {

    // }

    damage(projectile) {
        particle(this.particleColor(), [
            ['alpha', 1, 0, 1],
            ['size', rnd(2, 4), rnd(5, 10), 1],
            ['x', projectile.x, projectile.x + rnd(-20, 20), 1],
            ['y', projectile.y, projectile.y + rnd(-20, 20), 1]
        ]);
    }

    renderName() {
        wrap(() => {
            let x1 = cos(-PI / 4) * (this.radius + 20);
            let y1 = sin(-PI / 4) * (this.radius + 20);

            let x2 = cos(-PI / 4) * (this.radius + 50);
            let y2 = sin(-PI / 4) * (this.radius + 50);

            let x3 = x2 + 30;
            let y3 = y2;

            fs('#fff');
            R.strokeStyle = R.fillStyle;
            R.lineWidth = 2;
            beginPath();
            moveTo(x1, y1);
            lineTo(x2, y2);
            lineTo(x3, y3);
            stroke();

            R.lineWith = 8;
            translate(x3 + 10, y3 - 7);
            renderStickString(this.stickString, 10, 15, 1, 0, 0);
        });
    }

}

let rndArr = [0.1, 0.3, 0.2, 0.5];

class Star extends Body {

    constructor(rng) {
        super();
        this.radius = rng.between(100, 200);
        this.name = randomName(rng);
        this.stickString = stickString(this.name);
        // this.reachRadius = 0; // for reference only
        // this.systemDiscovered = 0; // for reference only
        this.halo = haloAround(createCanvas(this.radius * 2, this.radius * 2, () => 0), 100, 'rgba(255,0,0,0.3)', 'rgba(255,0,0,0)');

        this.gradient = createRadialGradient(0, 0, 0, 0, 0, this.radius);
        this.gradient.addColorStop(0, '#fff');
        this.gradient.addColorStop(0.3, '#ff0');
        this.gradient.addColorStop(1, '#f80');

        this.particleColor = () => '#ff0';
    }

    render() {
        if (V.isVisible(this, this.radius + 100)) {
            // if (true) {
            //     G.renderedStars++;
            // }

            drawImage(this.halo, this.x - this.halo.width / 2, this.y - this.halo.height / 2);

            translate(this.x, this.y);

            fs(this.gradient);
            beginPath();

            for (let i = 0 ; i < 40 ; i++) {
                let a = (i / 40) * TWO_PI;
                let d = sin(Date.now() / 1000 * 2 * TWO_PI + i * rndArr[i % rndArr.length]) * this.radius * 0.02 + this.radius * 0.98;

                R[i ? 'lineTo' : 'moveTo'](cos(a) * d, sin(a) * d);
            }
            fill();

            this.renderName();
        }
    }

    nameWithRelationship() {
        return this.name + '(star)';
    }

}

class Asteroid extends Body {

    constructor(radius, speed) {
        super();

        this.radius = radius || rnd(25, 50);
        this.reachRadius = this.radius * 5;

        this.health = this.radius / 25;

        this.rotation = 0;

        this.particleColor = () => pick(['#aaa', '#fff', '#ccc']);

        speed = speed || rnd(100, 200);

        let angle = random() * TWO_PI;
        this.vX = cos(angle) * speed;
        this.vY = sin(angle) * speed;

        this.rotationSpeed = rnd(PI / 2, PI / 4) * pick([-1, 1]);

        this.asset = createCanvas(this.radius * 2, this.radius * 2, r => {
            // Make sure we only fill the circle
            r.fs('#aaa');
            r.translate(this.radius, this.radius);
            r.beginPath();

            for (let i = 0 ; i < 40 ; i++) {
                let a = (i / 40) * TWO_PI;
                let d = rnd(this.radius * 0.75, this.radius);

                r[i ? 'lineTo' : 'moveTo'](cos(a) * d, sin(a) * d);
            }

            r.fill();

            r.globalCompositeOperation = 'destination-out';
            r.fs('#000');
            r.lineWidth = 2;
            for (let i = 0 ; i < 10 ; i++) {
                let a = rnd(0, TWO_PI);
                let d = rnd(0, this.radius * 1.5);
                r.beginPath();
                r.arc(cos(a) * d, sin(a) * d, rnd(this.radius * 2 / 25, this.radius * 5 / 25), 0, TWO_PI, 0);
                r.fill();
            }
        });
    }

    get speed() {
        return distP(0, 0, this.vX, this.vY);
    }

    cycle(e) {
        super.cycle(e);

        this.x += this.vX * e;
        this.y += this.vY * e;

        this.rotation += this.rotationSpeed * e;

        U.bodies.forEach(body => {
            if (body === this) {
                return;
            }

            let minDist = this.radius + body.radius;
            let overlap = minDist - dist(body, this);
            if (overlap > 0) {
                // Push the other body away
                let angle = angleBetween(body, this);
                this.x = body.x + cos(angle) * (minDist);
                this.y = body.y + sin(angle) * (minDist);

                // Using a ship constant LOL REMI WTF
                this.vX += cos(angle) * (overlap + 50 * 2);
                this.vY += sin(angle) * (overlap + 50 * 2);
            }
        });

        if (!V.isVisible(this, V.visibleWidth) && !this.preventAutomaticRemoval) {
            U.remove(U.bodies, this);
        }
    }

    render() {
        if (!V.isVisible(this, this.radius)) {
            return;
        }

        // if (true) {
        //     G.renderedAsteroids++;
        // }

        translate(this.x, this.y);
        rotate(this.rotation);

        drawImage(this.asset, -this.asset.width / 2, -this.asset.height / 2);
    }

    damage(projectile, amount) {
        super.damage(projectile);

        if (projectile.owner) {
            let x = projectile.speed * 0.05 * (1 - this.radius / 50);
            this.vX += cos(projectile.angle) * x;
            this.vY += sin(projectile.angle) * x;
        }

        if ((this.health -= amount) <= 0) {
            this.explode();
        }
    }

    explode() {
        U.dropResources(this.x, this.y, this.radius * 0.5);

        for (let i = 0 ; i < 50 ; i++) {
            let angle = random() * TWO_PI;
            let distance = random() * this.radius;

            particle(pick(['#aaa', '#fff', '#ccc']), [
                ['alpha', 1, 0, 1],
                ['size', rnd(2, 4), rnd(5, 10), 1],
                ['x', this.x + cos(angle) * distance, this.x + cos(angle) * distance + rnd(-20, 20), 1],
                ['y', this.y + sin(angle) * distance, this.y + sin(angle) * distance + rnd(-20, 20), 1]
            ]);
        }

        U.remove(U.bodies, this);

        if (this.radius > 23) {
            for (let i = 0 ; i < 2 ; i++) {
                let smallerAsteroid = new Asteroid(this.radius / 2, this.speed / 4);
                smallerAsteroid.x = this.x + rnd(-this.radius, this.radius);
                smallerAsteroid.y = this.y + rnd(-this.radius, this.radius);
                U.bodies.push(smallerAsteroid);
            }
        }

        explosionSound();
    }

}

class Planet extends Body {

    constructor(orbitsAround, orbitRadius, seed) {
        super();

        this.rng = createNumberGenerator(seed);

        this.radius = ~~this.rng.between(100, 200);
        this.reachRadius = this.radius * 4;

        this.civilization = new Civilization(this, this.rng.between(0, 0.7));

        this.name = randomName(this.rng);
        this.stickString = stickString(this.name);

        this.rotationSpeed = this.rng.between(PI / 8, PI / 12);

        this.particleColor = () => '#fff';

        this.orbitsAround = orbitsAround;
        this.orbitPhase = this.rng.between(0, TWO_PI);
        this.orbitRadius = orbitRadius;

        this.ring = this.rng.floating() < 0.3;

        this.stations = [];
        this.angle = 0;

        this.updatePosition();

        let initialResources = this.civilization.resources = rnd(50, 150);
        for (let i = 0 ; i < initialResources / 10 ; i++) {
            this.evolve();
        }

        this.asset = once(() => haloAround(createCanvas(this.radius * 2, this.radius * 2, r => {
            // Make sure we only fill the circle
            r.fs('#fff');
            r.arc(this.radius, this.radius, this.radius, 0 , TWO_PI);
            r.fill();
            r.globalCompositeOperation = 'source-atop';

            let rng = createNumberGenerator(this.name.charCodeAt(0) + this.radius);

            let rgb = [...Array(3)].map(() => rng.between(32, 255));

            for (let y = 0 ; y < this.radius * 2 ; y += rng.between(10, 20)) {
                r.fs('rgb' + '(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')');
                r.fillRect(0, y, this.radius * 2, this.radius * 2);

                // Update colors for the next stripe
                rgb = rgb.map(c => ~~limit(32, c + rng.between(-20, 20), 255));
            }
        }), 50, 'rgba(255,255,255,0.1)', 'rgba(255,255,255,0)'));

        this.shadowAsset = once(() => createCanvas(this.radius * 4, this.radius * 2, (r, c) => {
            let gradient = r.createLinearGradient(0, 0, c.width, 0);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            r.fs(gradient);
            r.globalAlpha = 0.4;

            r.beginPath();

            r.wrap(() => {
                r.translate(0, this.radius);
                r.scale(0.7, 1);
                r.arc(0, 0, this.radius, -PI / 2, PI / 2);
            });

            r.lineTo(c.width, c.height);
            r.lineTo(c.width, 0);

            r.fill();
        }));
    }

    updatePosition() {
        this.x = this.orbitsAround.x + cos(this.orbitPhase) * this.orbitRadius;
        this.y = this.orbitsAround.y + sin(this.orbitPhase) * this.orbitRadius;
    }

    cycle(e) {
        super.cycle(e);

        let yearTime = TWO_PI * this.orbitRadius / 25;
        let angularVelocity = TWO_PI / yearTime;

        this.orbitPhase += e * angularVelocity;

        this.updatePosition();
        this.angle += this.rotationSpeed * e;

        this.stations.forEach(station => station.cycle(e));

        this.civilization.resources = min(200, this.civilization.resources + e * 0.2);

        if ((this.nextEvolution -= e) < 0) {
            this.evolve();
        }

        // Show HUD prompt when player is within reach: unified prompt for friendly planets (Dock + Accept when offer present)
        try {
            let playerDistance = dist(this, U.playerShip);
            let friendly = this.civilization && this.civilization.relationshipType && this.civilization.relationshipType() === '#0f0';

            if (playerDistance < this.reachRadius && !this.showingPlanetPrompt) {
                this.showingPlanetPrompt = 1;
                let title = (this.name || 'Unknown');

                if (friendly) {
                    if (this.hasOffer) {
                        // Friendly planet with an incoming communication: show both Dock and Accept
                        G.showPrompt(`${title}\nPress [D] to dock\nPress [A] to accept incoming communication`);
                    } else {
                        // Friendly planet with no offer: show trade hint only
                        G.showPrompt(`${title} - Planetary Trade\nPress [D] to trade`);
                    }
                } else {
                    // Non-friendly planets: only show incoming communication hint if there's an offer
                    if (this.hasOffer) {
                        G.showPrompt(`${title}\nPress [A] to receive incoming communication`);
                    }
                }
            } else if (playerDistance >= this.reachRadius && this.showingPlanetPrompt) {
                this.showingPlanetPrompt = 0;
                G.showPrompt();
            }
            // note: accepting/ignoring offers or docking will clear offers or present other prompts as necessary elsewhere
        } catch (e) {
            // ignore if U.playerShip not available yet
        }
    }

    evolve() {
        if (this.civilization.resources >= 10) {
            this.civilization.resources -= 10;

            pick([
                () => this.spawnStation(City),
                () => this.spawnStation(Mortar),
                // () => this.spawnStation(Mountain),
                () => this.spawnStation(Factory),
                () => this.spawnShip()
            ])();

            this.nextEvolution = 20;
        }
    }

    spawnStation(type) {
        let maxStations = (TWO_PI * this.radius) / 30;

        let freeAngles = [];
        for (let a = 0 ; a < TWO_PI ; a += TWO_PI / maxStations) {
            freeAngles.push(a);
        }

        this.stations.forEach(station => U.remove(freeAngles, station.angleOnPlanet));

        if (freeAngles.length) {
            this.stations.push(new type(this, pick(freeAngles)));
        }
    }

    spawnShip() {
        U.ships.push(new AIShip(
            this.civilization,

            // Giving the ship a shitty position within the planet
            // AI ships fix their position automatically since they can't crash into their own planet
            this.x + rnd(-1, 1),
            this.y + rnd(-1, 1)
        ));
    }

    render() {
        if (!V.isVisible(this.orbitsAround, this.orbitRadius + this.radius * 2)) { // * 2 for the halo
            return;
        }

        // Draw the orbit
        R.lineWidth = 10;
        R.strokeStyle = 'rgba(255,255,255,0.1)';
        beginPath();
        arc(this.orbitsAround.x, this.orbitsAround.y, this.orbitRadius, 0, TWO_PI);
        stroke();

        // if (true) {
        //     G.renderedOrbits++;
        //
        //     // let pts = this.pointsAround([this.radius + 100, this.radius + 200]);
        //
        //     // R.lineWidth = 2;
        //     // pts.forEach(pt => {
        //     //     R.fs('#0f0');
        //     //     fillRect(pt.x - 2, pt.y - 2, 4, 4);
        //
        //     //     pt.neighbors.forEach(neighbor => {
        //     //         beginPath();
        //     //         R.strokeStyle = '#0f0';
        //     //         moveTo(pt.x, pt.y);
        //     //         lineTo(neighbor.x, neighbor.y);
        //     //         stroke();
        //     //     });
        //     // });
        // }

        if (!V.isVisible(this, this.radius + 50)) {
            return;
        }

        // if (true) {
        //     G.renderedPlanets++;
        // }

        R.strokeStyle = '#fff';
        R.lineWidth = 60;

        if (this.ring) {
            wrap(() => {
                R.globalAlpha = 0.5;
                translate(this.x, this.y);
                rotate(PI / 4);
                scale(1, 0.2);
                beginPath();
                arc(0, 0, this.radius * 1.5, 0, PI);
                stroke();
            });
        }

        this.stations.forEach(station => wrap(() => {
            translate(station.x, station.y);
            rotate(station.angleOnPlanet + this.angle);
            station.render();
        }));

        translate(this.x, this.y);

        wrap(() => {
            rotate(this.angle);
            drawImage(this.asset(), -this.asset().width / 2, -this.asset().height / 2);
        });

        // Draw an Incoming Communication icon if this planet currently has an offer
        try {
            if (this.hasOffer) {
                wrap(() => {
                    // draw a yellow triangle with a black exclamation mark centered on the planet
                    let size = Math.max(12, Math.min(24, ~~(this.radius / 2)));
                    fs('#ffd700');
                    R.strokeStyle = '#000';
                    R.lineWidth = 2;
                    beginPath();
                    moveTo(0, -size);
                    lineTo(-size, size);
                    lineTo(size, size);
                    closePath();
                    fill();
                    stroke();

                    // exclamation mark
                    fs('#000');
                    // narrow vertical bar
                    let barH = ~~(size * 0.6);
                    let barW = Math.max(2, ~~(size * 0.12));
                    fr(-barW/2, -barH/2, barW, barH);
                    // dot
                    beginPath();
                    arc(0, barH/2 + 2, Math.max(1.5, barW), 0, TWO_PI);
                    fill();
                });
            }
        } catch (e) { /* ignore rendering errors */ }

        wrap(() => {
            rotate(this.orbitPhase);
            drawImage(this.shadowAsset(), 0, -this.shadowAsset().height / 2);
        });

        if (this.ring) {
            wrap(() => {
                R.globalAlpha = 0.5;
                rotate(PI / 4);
                scale(1, 0.2);
                beginPath();
                arc(0, 0, this.radius * 1.5, -PI, 0);
                stroke();
            });
        }

        this.renderName();
    }

    nameWithRelationship() {
        return this.name + ' (' + (this.civilization.relationshipType() === '#f00' ? 'enemy' : 'ally') + ')';
    }

}

class Civilization {

    constructor(center, relationship) {
        this.resources = 0;
        this.center = center;
        this.relationship = relationship;
        // Numeric reputation score for trade UI and mission effects
        // Allies start at +100, enemies start at -100
        try {
            this.reputation = (this.relationship < 0.5) ? -100 : 100;
        } catch (e) { this.reputation = 0; }
        this.initialRelationship = this.relationshipType();
    }

    relationshipType() {
        return this.relationship < 0.5 ? '#f00' : '#0f0';
    }

    relationshipLabel() {
        return this.relationshipType() === '#f00' ? 'enemy' : 'ally';
    }

    updateRelationship(difference) {
        let relationshipTypeBefore = this.relationshipType();
        this.relationship = limit(0, this.relationship + difference, 1);

        if (this.relationshipType() !== relationshipTypeBefore) {
            G.showMessage(this.center.name + ' is now your ' + this.relationshipLabel());
        }
    }

    // Apply reputation numeric score to the normalized relationship value.
    // If reputation is non-negative, consider the civilization an ally; otherwise enemy.
    applyReputationToRelationship() {
        try {
            let before = this.relationshipType();
            // Map reputation to a relationship float around the ally/enemy threshold.
            if (typeof this.reputation === 'number' && this.reputation >= 0) {
                this.relationship = 0.75; // strong ally
            } else {
                this.relationship = 0.25; // enemy
            }
            if (this.relationshipType() !== before) {
                G.showMessage(this.center.name + ' is now your ' + this.relationshipLabel());
            }
        } catch (e) { /* ignore */ }
    }

}

class Ship {

    constructor(civilization) {
        this.civilization = civilization;

        this.x = this.y = 0;
        this.vX = this.vY = 0;

        // Controls
        this.thrust = 0;
        if (this.inTradingInterface) return;
        this.rotationDirection = 0;

        this.angle = 0;

        this.radius = 20;
        this.reachRadius = 200;

        this.health = 1;

        this.heat = 0;
    }

    cycle(e) {
        // If the ship is docked to a planet or station, lock its position to the dock target
        try {
            if (this.isDocked && (this.dockedPlanet || this.dockedStation)) {
                let dockTarget = this.dockedPlanet || this.dockedStation;
                if (this.dockOffset && typeof this.dockOffset.x === 'number' && typeof this.dockOffset.y === 'number') {
                    this.x = dockTarget.x + this.dockOffset.x;
                    this.y = dockTarget.y + this.dockOffset.y;
                } else {
                    // fallback: place at target edge
                    let angleToShip = angleBetween(dockTarget, this);
                    let dockDistance = (dockTarget.radius || 0) + 15;
                    this.x = dockTarget.x + Math.cos(angleToShip) * dockDistance;
                    this.y = dockTarget.y + Math.sin(angleToShip) * dockDistance;
                    this.dockOffset = { x: this.x - dockTarget.x, y: this.y - dockTarget.y };
                }
                // Prevent movement while docked
                this.vX = this.vY = 0;
                this.thrust = 0;
                if (this.inTradingInterface) return;
        this.rotationDirection = 0;
            } else {
                this.x += this.vX * e;
                this.y += this.vY * e;
            }
        } catch (e) {
            // fallback to original behavior on error
            this.x += this.vX * e;
            this.y += this.vY * e;
        }

        if (this.thrust && !this.uncontrolledRotation) {
            this.vX += this.thrust * cos(this.angle) * 400 * e;
            this.vY += this.thrust * sin(this.angle) * 400 * e;

            for (let i = 0 ; i < ceil(e * 60) ; i++) {
                particle('#fff', [
                    ['alpha', 1, 0, 1],
                    ['size', rnd(2, 4), rnd(5, 10), 1],
                    ['x', this.x, this.x + rnd(-20, 20), 1],
                    ['y', this.y, this.y + rnd(-20, 20), 1]
                ]);
            }
        }

        let angle = atan2(this.vY, this.vX);
        let velocity = min(max(0, distP(0, 0, this.vX, this.vY) - 50 * e), 500);

        this.vX = velocity * cos(angle);
        this.vY = velocity * sin(angle);

        this.angle += e * (this.uncontrolledRotation || this.rotationDirection) * 3;

        // Cooling behavior: allow ship-specific thermalRecovery to speed up cooldown.
        // thermalRecovery is treated as a multiplier where lower values are faster (Mod Bay reduces this value).
        try {
            let baseCoolingRate = 0.5; // default heat units per second
            let tr = (this.baseStats && typeof this.baseStats.thermalRecovery === 'number') ? this.baseStats.thermalRecovery : (typeof this.thermalRecovery === 'number' ? this.thermalRecovery : 1);
            // Protect against invalid values
            let effectiveRecovery = Math.max(0.05, tr); // clamp to avoid division by near-zero

            // Reduce heat once per cycle, but only after a short post-shot window to match original behavior.
            // This preserves the original 0.5s delay before cooling starts. If coolingDown due to overheat,
            // apply a larger factor to make overheat recovery slightly faster, but still wait the 0.5s.
            if ((G.clock - (this.lastShot || 0)) > 0.5) {
                let factor = this.coolingDown ? 1.5 : 1;
                this.heat -= e * (baseCoolingRate / effectiveRecovery) * factor;
            }

            if (this.heat <= 0) {
                this.heat = 0;
                this.coolingDown = 0;
            }
        } catch (e) {
            // fallback to original behaviour on error
            if ((G.clock - (this.lastShot || 0)) > 0.5) {
                this.heat -= e * 0.5;
            }

            if (this.heat <= 0) {
                this.coolingDown = 0;
            }
        }
    }

    // For reference only
    // shipColor() {

    // }

    render() {
        if (!V.isVisible(this, this.radius)) {
            return;
        }

        // if (true) {
        //     G.renderedShips++;
        // }

        // wrap(() => {
            fs(1 - limit(0, G.clock - this.lastDamage, 0.1) / 0.1 > 0 ? '#f00' : this.shipColor());
            translate(this.x, this.y);
            rotate(this.angle);
            beginPath();
            moveTo(-5, 0);
            lineTo(-10, 10);
            lineTo(20, 0);
            lineTo(-10, -10);
            fill();
        // });

        // Shadow effect relative to the closest star
        let closestStar = U.stars
            .reduce((closest, star) => !closest || dist(closest, this) > dist(star, this) ? star : closest, null);

        if (closestStar) {
            let angleToClosestStar = normalize(this.angle - angleBetween(this, closestStar));
            // let alpha = 1 - abs(abs(angleToClosestStar) / PI - 1 / 2) * 2;

            // wrap(() => {
                fs('#000');

                // This is crazy but I gotta save the byes
                R.globalAlpha = (1 - abs(abs(angleToClosestStar) / PI - 1 / 2) * 2) * limit(0, (1 - dist(closestStar, this) / 5000), 1);
                // translate(this.x, this.y);
                // rotate(this.angle);

                beginPath();
                moveTo(-5, 0);
                lineTo(-10, sign(angleToClosestStar) * 10);
                lineTo(20, 0);
                fill();
            // });
        }
    }

    shoot(type, interval = 0.1) {
        if ((G.clock - (this.lastShot || 0)) < interval || this.coolingDown) {
            return;
        }

        this.lastShot = G.clock;

        let projectile = new type(this, this.x, this.y, this.angle);
        this.modifyProjectile(projectile);
        U.projectiles.push(projectile);

        this.heat = min(1, max(this.heat, 0) + projectile.heat);

        G.eventHub.emit(2, projectile);

        if (this.heat >= 1) {
            this.coolingDown = 1;
        }
    }

    modifyProjectile() {
        // nothing, PlayerShip needs this tho
    }

    damage(projectile, amount) {
        // Invulnerable while docked
        try { if (this.isDocked) return; } catch (e) {}
        particle('#ff0', [
            ['alpha', 1, 0, 1],
            ['size', rnd(2, 4), rnd(5, 10), 1],
            ['x', this.x, this.x + rnd(-20, 20), 1],
            ['y', this.y, this.y + rnd(-20, 20), 1]
        ]);

        this.lastDamage = G.clock;

        if ((this.health -= amount) <= 0.05) {
            this.explode(projectile);
        }
    }

    explode() {
        this.health = 0;

        for (let i = 0 ; i < 100 ; i++) {
            let angle = random() * TWO_PI;
            let distance = rnd(5, 50);
            let d = rnd(0.2, 1.5);

            particle(pick(['#ff0', '#f80', '#f00']), [
                ['alpha', 1, 0, d],
                ['size', rnd(2, 4), rnd(5, 10), d],
                ['x', this.x, this.x + cos(angle) * distance, d],
                ['y', this.y, this.y + sin(angle) * distance, d]
            ]);
        }

        // Determine if this ship should drop cargo on destruction: enemy civilizations (or pirates as fallback)
        let shouldDropCargo = 0;
        try {
            if (this.civilization && typeof this.civilization.relationshipType === 'function') {
                shouldDropCargo = (this.civilization.relationshipType() === '#f00');
            }
        } catch (e) { shouldDropCargo = 0; }

        // Fallback to pirate-specific list if relationship info not available
        try {
            if (!shouldDropCargo && U.pirates && U.pirates.indexOf(this) >= 0) shouldDropCargo = 1;
        } catch (e) {}

        U.remove(U.ships, this);
        U.remove(U.pirates, this);

        if (V.isVisible(this)) {
            explosionSound();
        }

        // Drop raw resources
        U.dropResources(this.x, this.y, 10);

        // If this ship qualifies, perform drop checks: 1/3 chance to drop cargo, 1/3 chance to drop credits
        try {
            // Drop raw resources and possible cargo/credits only if the destroyed ship is near the player's ship.
            // This avoids cluttering the world with loot from distant fights the player cannot reach.
            try {
                let DROP_NEARBY_DISTANCE = 800; // distance threshold for loot to be dropped (in game units)
                let playerShip = (typeof U !== 'undefined') ? U.playerShip : null;
                let tooFar = playerShip ? (dist(this, playerShip) > DROP_NEARBY_DISTANCE) : 0;

                if (!tooFar) {
                    // Drop raw resources
                    U.dropResources(this.x, this.y, 10);

                    // If this ship qualifies, perform drop checks: 1/3 chance to drop cargo, 1/3 chance to drop credits
                    if (shouldDropCargo) {
                        // chance to drop cargo based on configured constant
                        if (typeof 0.3333333 !== 'undefined' ? (Math.random() < 0.3333333) : (Math.random() < (1/3))) {
                            // Choose a cargo type (random) from CARGO_DATA if available, otherwise fallback name
                            let cargoName = 'Cryogenic Embryos';
                            let units = 1 + Math.floor(Math.random() * 20); // 1-20 units
                            try {
                                if (typeof CARGO_DATA !== 'undefined' && Array.isArray(CARGO_DATA) && CARGO_DATA.length) {
                                    try {
                                        // Compute weighted probabilities so low-value items are more likely.
                                        // Anchors: lowest-value -> 10x, Helix Seeds -> 5x, highest-value -> 1x.
                                        let vals = CARGO_DATA.map(d => (d && typeof d.value === 'number') ? d.value : 1);
                                        let minVal = Math.min.apply(null, vals);
                                        let maxVal = Math.max.apply(null, vals);

                                        // Try to find helix seeds value; fallback to median-like value
                                        let helixDef = CARGO_DATA.find(d => d && d.cargo && d.cargo.toLowerCase().includes('helix'));
                                        let helixVal = helixDef && typeof helixDef.value === 'number' ? helixDef.value : Math.max(minVal, Math.min(maxVal, (minVal + maxVal) / 4));

                                        let log = v => Math.log(Math.max(1e-6, v));

                                        // Linear interpolate on log-value between anchors
                                        let calcWeight = (v) => {
                                            try {
                                                if (v <= helixVal) {
                                                    let t = (log(v) - log(minVal)) / Math.max(1e-6, (log(helixVal) - log(minVal)));
                                                    return 10 - (10 - 5) * limit(0, t, 1); // 10 -> 5
                                                } else {
                                                    let t = (log(v) - log(helixVal)) / Math.max(1e-6, (log(maxVal) - log(helixVal)));
                                                    return 5 - (5 - 1) * limit(0, t, 1); // 5 -> 1
                                                }
                                            } catch (e) { return 1; }
                                        };

                                        let weights = CARGO_DATA.map(d => calcWeight((d && typeof d.value === 'number') ? d.value : 1));
                                        let total = weights.reduce((s, w) => s + (isFinite(w) ? w : 0), 0);
                                        let r = Math.random() * total;
                                        let chosen = 0;
                                        for (let i = 0; i < weights.length; i++) {
                                            r -= weights[i];
                                            if (r <= 0) { chosen = i; break; }
                                        }

                                        let def = CARGO_DATA[chosen];
                                        if (def && def.cargo) cargoName = def.cargo;
                                    } catch (e) {
                                        // fallback to uniform selection
                                        let idx = Math.floor(Math.random() * CARGO_DATA.length);
                                        let def = CARGO_DATA[idx];
                                        if (def && def.cargo) cargoName = def.cargo;
                                    }
                                }
                            } catch (e) {}

                            // Ensure the CargoItem class is available (it should be included in build)
                            if (typeof CargoItem !== 'undefined') {
                                console.log('Dropping CargoItem', cargoName, units, 'at', this.x, this.y);
                                U.items.push(new CargoItem(this.x, this.y, cargoName, units));
                            } else {
                                // Fallback: create a ResourceItem if CargoItem not present
                                console.log('CargoItem not defined, dropping ResourceItem as fallback');
                                U.items.push(new ResourceItem(this.x, this.y));
                            }
                        }

                        // Independently, chance to drop credits based on configured constant
                        if (typeof 0.3333333 !== 'undefined' ? (Math.random() < 0.3333333) : (Math.random() < (1/3))) {
                            try {
                                // Compute base credit amount
                                let baseMin = (typeof 10 !== 'undefined') ? 10 : 10;
                                let baseMax = (typeof 99 !== 'undefined') ? 99 : 99;
                                let randBase = baseMin + Math.floor(Math.random() * Math.max(1, (baseMax - baseMin + 1)));

                                // Scale by ship radius (proxy for size/level)
                                let scaleFactor = (typeof 0.1 !== 'undefined') ? 0.1 : 0.1;
                                let scaled = Math.round(randBase + (this.radius * scaleFactor));

                                let amount = Math.max(baseMin, scaled);

                                if (typeof CreditItem !== 'undefined') {
                                    U.items.push(new CreditItem(this.x, this.y, amount));
                                } else {
                                    U.items.push(new ResourceItem(this.x, this.y));
                                }
                            } catch (e) {
                                U.items.push(new ResourceItem(this.x, this.y));
                            }
                        }
                    }
                } else {
                    // Too far from player; skip dropping loot
                    try { console.debug && console.debug('explode: ship too far from player, skipping drops', dist(this, playerShip)); } catch (e) {}
                }
            } catch (e) {
                // ignore errors here to avoid crashing on explosion
                console.error('Error dropping cargo/credits items:', e);
            }
        } catch (e) {
            // ignore any unexpected errors during explosion handling
        }
    }
}

class PlayerShip extends Ship {

    constructor(x, y) {
        super(new Civilization(), x, y);

        this.angle = -PI / 8;
        this.nextHealing = 0;
        this.shield = 1;
        this.age = 0;
    }

    cycle(e) {
        this.age += e;

        // // Hairy condition here: we only want to brake if the user is pressing the down arrow AND we're moving towards the same direction we're pointing to
        // // This is to avoid having a reverse mode
        // this.thrust = (w.down[40] && (this.vX || this.vY) && abs(normalize(atan2(this.vY, this.vX) - this.angle)) < PI / 2) ?
        //     -1 : (w.down[38] ? 1 : 0);
        this.thrust = w.down[38] ? 1 : (w.down[40] ? -0.25 : 0);

        this.rotationDirection = w.down[37] ? -1 : (w.down[39] ? 1 : 0);

        if (w.down[83] && this.inTradingInterface && (this.dockedStation || this.dockedPlanet)) { /* S key for Sell */
            const playerResources = this.civilization ? this.civilization.resources : 0;
            if (playerResources > 0) {
                if (this.dockedStation) this.dockedStation.sellResources();
                else if (this.dockedPlanet && this.dockedPlanet.sellResources) this.dockedPlanet.sellResources();
            }
        }
        if (w.down[82] && this.inTradingInterface && (this.dockedStation || this.dockedPlanet)) { /* R key for Repair */
            const repairCost = 20;
            const playerCredits = this.credits || 0;
            if (playerCredits >= repairCost && (this.health < 1 || this.shield < 1)) {
                if (this.dockedStation) this.dockedStation.repairShip();
                else if (this.dockedPlanet && this.dockedPlanet.repairShip) this.dockedPlanet.repairShip();
            }
        }
        if (w.down[76] && this.inTradingInterface && (this.dockedStation || this.dockedPlanet)) { /* L key for Leave */
            if (this.dockedStation) this.dockedStation.undock();
            else if (this.dockedPlanet && window.planetaryUndock) window.planetaryUndock();
        }
        if (w.down[27] && this.inTradingInterface && (this.dockedStation || this.dockedPlanet)) { /* Escape key for Leave */
            if (this.dockedStation) this.dockedStation.undock();
            else if (this.dockedPlanet && window.planetaryUndock) window.planetaryUndock();
        }
        if (w.down[32] && !this.inTradingInterface) this.shoot(SimpleLaser);
        if (w.down[13] && this.age > 1) this.shoot(SuperLaser, 0.5);

        let nearStar = this.nearStar();
        if (nearStar) {
            this.damage(nearStar, e * 0.15);
        }

        if ((G.clock - this.lastShieldDamage) > 5) {
            this.shield += 0.05 * e;
        }
        this.shield = min(this.health, this.shield); // make sure shields don't surpass health

        if ((this.nextHealing -= e) < 0) {
            this.heal();
        }

        super.cycle(e);

        if (this.thrust) {
            if (!this.thrustSound) {
                this.thrustSound = thrustSound();
                this.thrustSound.loop = 1;
            }
        } else if (this.thrustSound) {
            this.thrustSound.pause();
            this.thrustSound = 0;
        }
    }

    heal() {
        let healingAmount = min(1 - this.health, 0.1);
        let requiredResources = ~~(10 * healingAmount / 0.1);
        if (this.civilization.resources >= requiredResources && healingAmount > 0) {
            G.healAnimation(() => {
                this.health += healingAmount;
                this.civilization.resources -= requiredResources;
            });
        }

        this.nextHealing = 1;
    }

    damage(source, amount) {
        if (this.isDocked) return; // Invulnerable while docked
        let isStar = source instanceof Star;

        if (this.shield > 0) {
            try {
                // Scale incoming damage by the ship's shield base so upgrades increase effective HP.
                let shieldBase = (this.baseStats && this.baseStats.maxShieldPoints) ? this.baseStats.maxShieldPoints : 100;
                let shieldScale = Math.max(1, shieldBase / 100);
                this.shield -= (amount / shieldScale);
            } catch (e) {
                this.shield -= amount;
            }

            if (!isStar || (G.clock - (this.lastShieldDamage || 0)) > 0.3) {
                this.lastShieldDamage = G.clock;

                this.shieldEffectAngle = angleBetween(this, source);
                interp(this, 'shieldEffectScale', 0.8, 1, 0.2);
            }
            return;
        }

        if (!isStar) {
            V.shake(0.1);
        }

        try {
            let hullBase = (this.baseStats && this.baseStats.maxHullPoints) ? this.baseStats.maxHullPoints : 100;
            let hullScale = Math.max(1, hullBase / 100);
            super.damage(source, (amount * 0.5) / hullScale); // Less damage for the player, scaled by hull base
        } catch (e) {
            super.damage(source, amount * 0.5);
        }

        this.nextHealing = 5;
    }

    modifyProjectile(projectile) {
        projectile.guideRadius = 100;
        try {
            // Compute cumulative increase matching Mod Bay rules
            function incrementPercentForLevel(level) {
                let next = level + 1;
                if (next === 2) return 0.75;
                if (next === 3) return 0.5;
                if (next === 4) return 0.25;
                return 0.2;
            }
            function cumulativeIncrease(level) {
                let sum = 0;
                for (let l = 1; l < level; l++) sum += incrementPercentForLevel(l);
                return sum;
            }

            // Apply torpedo (SuperLaser) damage multiplier
            let ctorName = (projectile && projectile.constructor && projectile.constructor.name) || '';
            if (ctorName === 'SuperLaser') {
                let lvl = (this.upgrades && this.upgrades.torpedos) || 1;
                let inc = cumulativeIncrease(lvl);
                let before = projectile.damage;
                let after = +(before * (1 + inc)).toFixed(6);
                projectile.damage = after;
                try { console.debug('mod-bay: applied torpedos upgrade to SuperLaser damage', 'level', lvl, before, '->', after); } catch (e) {}
            }

            // Apply phaser (SimpleLaser) damage multiplier
            if (ctorName === 'SimpleLaser') {
                let lvl = (this.upgrades && this.upgrades.phasers) || 1;
                let inc = cumulativeIncrease(lvl);
                let before = projectile.damage;
                let after = +(before * (1 + inc)).toFixed(6);
                projectile.damage = after;
                try { console.debug('mod-bay: applied phasers upgrade to SimpleLaser damage', 'level', lvl, before, '->', after); } catch (e) {}
            }
        } catch (e) { console.error('modifyProjectile upgrade application error', e); }
    }

    shipColor() {
        return '#fff';
    }

    explode(projectile) {
        super.explode(projectile);
        // Respawn flow: preserve upgrades/baseStats but reset credits and cargo.
        setTimeout(() => {
            try {
                // Persist upgrades/baseStats to storage so restoreState can pick them up
                if (typeof U !== 'undefined' && typeof U.saveState === 'function') {
                    try { U.saveState(); } catch (e) {}
                }

                // Create a fresh player ship (this will reset credits and cargo by design)
                if (typeof U !== 'undefined' && typeof U.createPlayerShip === 'function') {
                    try { U.createPlayerShip(); } catch (e) {}
                }

                // Reapply persisted upgrades/baseStats to the new ship
                if (typeof U !== 'undefined' && typeof U.restoreState === 'function') {
                    try { U.restoreState(); } catch (e) {}
                }

                try { G.showMessage && G.showMessage('You have respawned. Upgrades preserved.'); } catch (e) {}
            } catch (e) {}
        }, 2000);

        if (this.thrustSound) {
            this.thrustSound.pause();
        }
    }

    currentWarning() {
        if (this.health <= 0.3) {
            return 'CRITICAL HULL DAMAGE' + (this.civilization.resources < 10 ? '. FIND RESOURCES TO REPAIR' : '');
        }

        if (this.nearStar()) {
            return 'CRITICAL HEAT';
        }

        if (U.pirates.filter(ship => dist(ship, this) < 1000).length) {
            return 'PIRATES NEARBY';
        }

        if (this.shield <= 0) {
            return 'SHIELDS OFFLINE';
        }
    }

    nearStar() {
        return U.stars.filter(star => dist(this, star) < star.radius * 2)[0];
    }

    render() {
        wrap(() => super.render());

        translate(this.x, this.y);
        rotate(this.shieldEffectAngle);

        fs('#fff');

        beginPath();
        arc(0, 0, 25, -PI / 2, PI / 2);

        wrap(() => {
            scale(this.shieldEffectScale, 1);
            arc(0, 0, 25, PI / 2, -PI / 2, 1);
        });

        fill();
    }

}

class AIShip extends Ship {

    constructor(civilization, x, y) {
        super(civilization);
        this.nextDecisionChange = 0;

        this.x = x;
        this.y = y;
    }

    shipColor() {
        return this.civilization.relationshipType();
    }

    canShootEnemy() {
        if (!this.enemy) {
            return 0;
        }

        if (dist(this, this.enemy) > 400 && dist(this.civilization.center, this.enemy) > this.civilization.center.radius * 2) {
            return 0;
        }

        if (dist(this.civilization.center, this.enemy) < this.civilization.center.radius) {
            return 0;
        }

        return 1;
    }

    currentTarget() {
        if (this.canShootEnemy()) {
            return this.enemy;
        }

        return this.target;
    }

    updateControls() {
        if (this.inTradingInterface) return;
        this.rotationDirection = 0;
        this.thrust = 0;

        let target = this.currentTarget();
        if (!target) {
            return;
        }

        let velocity = distP(0, 0, this.vX, this.vY);

        // Logic to reach the current target
        let angleToTarget = angleBetween(this, target);
        let angleDiff = normalize(angleToTarget - this.angle);

        if (abs(angleDiff) > PI / 64) {
            this.rotationDirection = sign(angleDiff);
        }

        if (abs(angleDiff) < PI / 64) {
            let moveAngle = atan2(this.vY, this.vX);
            let fullStopIn = velocity / 50;
            let distAtFullStop = -50 * fullStopIn * fullStopIn / 2 + velocity * fullStopIn;
            let positionAtFullStop = {
                'x': this.x + distAtFullStop * cos(moveAngle),
                'y': this.y + distAtFullStop * sin(moveAngle)
            };

            let distanceToTargetAtFullStop = dist(positionAtFullStop, target);
            this.thrust = distanceToTargetAtFullStop > 50 ? 1 : 0;
        }

        if (this.canShootEnemy()) {
            if (abs(angleDiff) > PI / 64 && !this.coolingDown) {
                this.heat += 0.08; // hack to make AI ships shoot shorter bursts
                this.shoot(SimpleLaser);
            }
        }

        if (velocity > 250) {
            this.thrust = 0;
        }
    }

    cycle(e) {
        if (!V.isVisible(this, 500)) {
            return;
        }

        this.enemy = this.civilization.relationshipType() === '#f00' ? U.playerShip : null;

        if (!this.target || dist(this, this.target) < this.targetRadius || dist(this.civilization.center, this.target) < this.civilization.center.radius || (this.nextDecisionChange -= e) <= 0) {
            this.pickNewTarget();
        }

        this.updateControls();
        super.cycle(e);

        if (this.civilization.center.name) { // helps avoid having pirates being pushed by their center
            let angleWithPlanet = angleBetween(this.civilization.center, this);
            let distanceToPlanet = max(dist(this, this.civilization.center), this.civilization.center.radius + this.radius * 2);

            this.x = this.civilization.center.x + cos(angleWithPlanet) * distanceToPlanet;
            this.y = this.civilization.center.y + sin(angleWithPlanet) * distanceToPlanet;
        }
    }

    // render() {
    //     if (!V.isVisible(this, 500)) {
    //         return;
    //     }
    //
    //     if (true) {
    //         let velocity = distP(0, 0, this.vX, this.vY);
    //         let moveAngle = atan2(this.vY, this.vX);
    //         let fullStopIn = velocity / 50;
    //         let distAtFullStop = -50 * fullStopIn * fullStopIn / 2 + velocity * fullStopIn;
    //         let positionAtFullStop = {
    //             'x': this.x + distAtFullStop * cos(moveAngle),
    //             'y': this.y + distAtFullStop * sin(moveAngle)
    //         };
    //
    //         wrap(() => {
    //             R.fillStyle = '#f00';
    //             fr(positionAtFullStop.x, positionAtFullStop.y, 10, 10);
    //
    //             // fillText(distP(0, 0, this.vX, this.vY) / 50 + '', this.x + 50, this.y + 50);
    //
    //             if (this.currentTarget()) {
    //                 R.strokeStyle = '#f00';
    //                 beginPath();
    //                 // arc(this.currentTarget().x, this.currentTarget().y, this.targetRadius, 0, TWO_PI);
    //                 moveTo(this.x, this.y);
    //                 lineTo(this.currentTarget().x, this.currentTarget().y);
    //                 stroke();
    //             }
    //         });
    //     }
    //
    //     super.render();
    // }

    pickNewTarget() {
        let pts = pointsAround(this.civilization.center, [this.civilization.center.radius + 150, this.civilization.center.radius + 250]);

        let closestNode = target => pts.slice().sort((a, b) => {
            return dist(a, target) - dist(b, target);
        })[0];

        // Find the node we're the closest to
        let nodeStart = closestNode(this);
        let nodeEnd = U.enemy ? closestNode(U.enemy) : pick(nodeStart.neighbors);

        let closestNodeToTarget = nodeStart.neighbors.concat([nodeStart]).reduce((closest, node) => {
            return !closest || dist(node, nodeEnd) < dist(closest, nodeEnd) ? node : closest;
        }, null);

        this.targetRadius = 50;

        // If the node we picked is further than the target, might as well go for the target instead
        this.target = dist(this, closestNodeToTarget) > dist(this, nodeEnd) ? nodeEnd : closestNodeToTarget;

        this.nextDecisionChange = 2;
    }

    damage(projectile, amount) {
        super.damage(projectile, amount);

        if (projectile.owner === U.playerShip) {
            this.civilization.updateRelationship(-0.05);
        }
    }

    explode(projectile) {
        super.explode(projectile);

        if (projectile.owner === U.playerShip) {
            this.civilization.updateRelationship(-0.3);
        }
    }

}

class PlanetaryStation {

    constructor(planet, angleOnPlanet) {
        this.planet = planet;
        this.angleOnPlanet = angleOnPlanet;
        this.radius = 15;

        this.scale = 1;
        this.lastDamage = 0;

        this.health = 1;
    }

    get globalAngle() {
        return this.angleOnPlanet + this.planet.angle;
    }

    cycle() {
        this.x = this.planet.x + (this.planet.radius - 2) * cos(this.globalAngle);
        this.y = this.planet.y + (this.planet.radius - 2) * sin(this.globalAngle);
    }

    render() {
        let damageFactor = 1 - limit(0, G.clock - this.lastDamage, 0.1) / 0.1;

        scale(1 + damageFactor * 0.2, 1 + damageFactor * 0.2);

        fs(damageFactor > 0 ? '#fff' : ((this.planet.civilization.relationshipType() === '#f00' || this.planet.civilization.wasAttackedByPlayer) ? '#f00' : (this.planet.civilization.relationshipType() === '#0f0' ? '#0f0' : '#ff0')));
        this.renderGraphic();
    }

    // // For reference only
    // renderGraphic() {

    // }

    damage(source, amount) {
        if (this.isDocked) return; // Invulnerable while docked
        if (source.owner == U.playerShip) { // only get damage from the player (prevents mortars from destroying friendly stations)
            particle('#ff0', [
                ['alpha', 1, 0, 1],
                ['size', rnd(2, 4), rnd(5, 10), 1],
                ['x', this.x, this.x + rnd(-20, 20), 1],
                ['y', this.y, this.y + rnd(-20, 20), 1]
            ]);

            this.lastDamage = G.clock;

            this.planet.civilization.updateRelationship(-0.05);

            if ((this.health -= amount) <= 0) {
                this.explode(source);
            }
        }
    }

    explode(source) {
        for (let i = 0 ; i < 50 ; i++) {
            let angle = this.globalAngle + rnd(-PI / 2, PI / 2);
            let distance = rnd(30, 50);

            particle(pick(['#ff0', '#f80', '#f00']), [
                ['alpha', 1, 0, 1],
                ['size', rnd(2, 4), rnd(5, 10), 1],
                ['x', this.x, this.x + cos(angle) * distance, 1],
                ['y', this.y, this.y + sin(angle) * distance, 1]
            ]);
        }

        U.remove(this.planet.stations, this);

        if (source == U.playerShip) {
            this.planet.civilization.updateRelationship(-0.2);
        }

        G.eventHub.emit(0, this);

        U.dropResources(this.x, this.y, 10);
    }

}

class City extends PlanetaryStation {

    renderGraphic() {
        fr(0, -11, 10, 6); // left
        fr(0, -3, 20, 6); // center building
        fr(0, 5, 6, 6); // right
    }

}

class Mortar extends PlanetaryStation {

    constructor(planet, angleOnPlanet) {
        super(planet, angleOnPlanet);
        this.shootAngle = 0;
    }

    renderGraphic() {
        beginPath();
        arc(0, 0, 10, 0, TWO_PI);
        fill();

        rotate(this.shootAngle);
        fr(0, -2, 20, 4);
    }

    cycle(e) {
        super.cycle(e);

        // Smooth angle transition
        let angleToPlayer = normalize(angleBetween(this, U.playerShip) - this.globalAngle);
        let targetAngle = limit(-PI / 4, angleToPlayer, PI / 4);
        let maxRotation = e * PI / 4;
        this.shootAngle += limit(-maxRotation, targetAngle - this.shootAngle, maxRotation);

        if (dist(this, U.playerShip) < 500 && abs(normalize(this.shootAngle - angleToPlayer)) < PI / 64 && this.planet.civilization.relationshipType() === '#f00') {
            this.shoot();
        }
    }

    shoot() {
        if (G.clock - (this.lastShot || 0) < 3) {
            return;
        }

        this.lastShot = G.clock;

        let angle = this.globalAngle + this.shootAngle;
        U.projectiles.push(new SuperLaser(this, this.x + cos(angle) * (this.radius + 15), this.y + sin(angle) * (this.radius + 15), angle));
    }

}

class Factory extends PlanetaryStation {

    renderGraphic() {
        beginPath();
        moveTo(0, -10);
        lineTo(10, -10);
        lineTo(7, -2);
        lineTo(10, -2);
        lineTo(7, 6);
        lineTo(18, 6);
        lineTo(18, 9);
        lineTo(0, 9);
        fill();
    }

}

// Reusable menu panel creator
(function(){
    // Basic CSS for menu panels (kept consistent with prior trading panel look)
    let css = `
/* Styling applies to the generic menu panel id, the legacy trading-panel id, and any element with class .menu-panel */
.menu-panel, #menu-panel, #trading-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 20, 40, 0.95);
    border: 2px solid #00ffff;
    border-radius: 10px;
    padding: 20px;
    color: #ffffff;
    font-family: monospace;
    font-size: 14px;
    min-width: 360px;
    max-width: 520px;
    z-index: 10000;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
}
    /* Panel header inline message */
    .menu-panel .panel-message, #menu-panel .panel-message, #trading-panel .panel-message {
        color: #f88;
        margin-top: 6px;
        min-height: 18px;
        transition: opacity 0.25s ease;
        opacity: 1;
    }
    .menu-panel .panel-message:empty, #menu-panel .panel-message:empty, #trading-panel .panel-message:empty { opacity: 0; }

    /* Shared price tooltip */
    .menu-panel .price-tooltip, #menu-panel .price-tooltip, #trading-panel .price-tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(0,0,0,0.85);
        color: #fff;
        padding: 6px 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 9999;
        display: none;
        white-space: nowrap;
        box-shadow: 0 0 8px rgba(0,0,0,0.6);
        transition: opacity 0.08s ease;
    }

    /* Price elements */
    .menu-panel .price-el, #menu-panel .price-el, #trading-panel .price-el,
    .menu-panel .inv-price-el, #menu-panel .inv-price-el, #trading-panel .inv-price-el {
        margin-left: 8px;
        font-weight: bold;
    }

    /* Buy controls and qty UI */
    .menu-panel .controls, #menu-panel .controls, #trading-panel .controls { margin-left: 8px; }
    .menu-panel .qty-wrapper, #menu-panel .qty-wrapper, #trading-panel .qty-wrapper { display: none; align-items: center; }
    .menu-panel .qty-wrapper.open, #menu-panel .qty-wrapper.open, #trading-panel .qty-wrapper.open { display: inline-flex; }
    .menu-panel .qty-input, #menu-panel .qty-input, #trading-panel .qty-input { width: 48px; margin-right: 4px; font-family: monospace; }
    .menu-panel .controls button, #menu-panel .controls button, #trading-panel .controls button { margin-right: 6px; }

    /* Utility classes */
    .menu-panel .hidden, #menu-panel .hidden, #trading-panel .hidden { display: none !important; }
    .menu-panel .sell-btn, #menu-panel .sell-btn, #trading-panel .sell-btn { margin-left: 8px; }

    /* Capacity & credits indicators */
    .menu-panel .capacity-indicator, #menu-panel .capacity-indicator, #trading-panel .capacity-indicator,
    .menu-panel .credits-indicator, #menu-panel .credits-indicator, #trading-panel .credits-indicator {
        margin: 6px 0 12px 0;
        font-weight: bold;
        color: #ffd;
    }
 .menu-panel h2, #menu-panel h2, #trading-panel h2 { color: #00ffff; text-align: center; margin: 0 0 12px 0; font-size: 18px; }
 .menu-panel .section, #menu-panel .section, #trading-panel .section { margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; }
 .menu-panel .section h3, #menu-panel .section h3, #trading-panel .section h3 { color: #ffff00; margin: 0 0 8px 0; font-size: 14px; }
 .menu-panel .info-row, #menu-panel .info-row, #trading-panel .info-row { display:flex; justify-content:space-between; margin:6px 0; }
 .menu-panel .buttons, #menu-panel .buttons, #trading-panel .buttons { display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
 .menu-panel button, #menu-panel button, #trading-panel button { background:#004080; border:1px solid #00ffff; color:#fff; padding:8px 14px; border-radius:5px; cursor:pointer; font-family:monospace; font-size:12px; }
 .menu-panel button:hover, #menu-panel button:hover, #trading-panel button:hover { background:#0066cc; box-shadow:0 0 5px rgba(0,255,255,0.5); }
 .menu-panel button:disabled, #menu-panel button:disabled, #trading-panel button:disabled { background:#333; color:#666; cursor:not-allowed; }
`;

    // Inject CSS once
    let injected = 0;
    function ensureCSS() {
        if (injected) return;
        injected = 1;
        try {
            console.debug('menu-panel: injecting CSS');
            let style = document.createElement('style');
            style.setAttribute('id', 'menu-panel-css');
            style.innerHTML = css;
            document.head.appendChild(style);
        } catch (e) { /* ignore */ }
    }

    // Helper to create a panel
    window.createMenuPanel = function(options) {
        try { console.debug('createMenuPanel called', options && options.id, options && options.title); } catch(e) {}
        // options: { id?, title, sections: [{title, rows: [{label, value}] , html?}], buttons: [{label, onClick, disabled}], onClose }
        ensureCSS();

        let existing = document.getElementById(options.id || 'menu-panel');
        if (existing) existing.remove();

        let panel = document.createElement('div');
        panel.id = options.id || 'menu-panel';
        // Also add a class so CSS can target it regardless of id
        try { panel.classList.add('menu-panel'); } catch (e) {}

        let titleHtml = `<h2>${options.title || ''}</h2>`;

        let bodyHtml = '';
        if (options.sections && options.sections.length) {
            options.sections.forEach(sec => {
                if (sec.html) {
                    bodyHtml += `<div class="section">${sec.html}</div>`;
                } else {
                    bodyHtml += `<div class="section">`;
                    if (sec.title) bodyHtml += `<h3>${sec.title}</h3>`;
                    if (sec.rows && sec.rows.length) {
                        sec.rows.forEach(r => {
                            bodyHtml += `<div class="info-row"><span>${r.label}</span><span>${r.value}</span></div>`;
                        });
                    }
                    if (sec.extraHtml) bodyHtml += sec.extraHtml;
                    bodyHtml += `</div>`;
                }
            });
        }

        // Buttons - create elements and attach handlers BEFORE appending to document
        let buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'buttons';

        // Helper to attach a deferred click handler to a button element
        function attachDeferredHandler(btnEl, b, idx) {
            try { console.debug && console.debug('menu-panel: attaching handler', panel.id, idx, b && b.label); } catch (e) {}
            btnEl.addEventListener('click', (ev) => {
                try {
                    setTimeout(() => {
                        try {
                            try { console.debug('menu-panel: deferred click executing', panel.id, idx, b && b.label); } catch (e) {}
                            if (typeof b.onClick === 'function') b.onClick(ev);
                        } catch (e) { console.error(e); }
                        try {
                            if (b.autoClose === 1) panel.remove();
                            if (options.onClose) options.onClose();
                        } catch (e) { console.error('menu-panel post-click error', e); }
                    }, 0);
                } catch (e) {
                    console.error('menu-panel click scheduling error', e);
                }
            });
        }

        if (options.buttons && options.buttons.length) {
            options.buttons.forEach((b, i) => {
                let btn = document.createElement('button');
                try { btn.textContent = b.label; } catch (e) { btn.innerText = b.label || '...'; }
                if (b.disabled) btn.disabled = 1;
                attachDeferredHandler(btn, b, i);
                buttonsContainer.appendChild(btn);
            });
        }

        // Always include a Close button unless explicitly disabled
        if (!options.noClose) {
            let closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.addEventListener('click', () => {
                try { panel.remove(); } catch (e) {}
                if (options.onClose) options.onClose();
            });
            buttonsContainer.appendChild(closeBtn);
        }

        panel.innerHTML = titleHtml + bodyHtml;
        panel.appendChild(buttonsContainer);

        // Append panel to document AFTER handlers are attached
        document.body.appendChild(panel);

        // Debug: print button labels and autoClose flags for runtime inspection
        try {
            let btnInfos = (options.buttons || []).map(b => ({ label: b.label, autoClose: b.autoClose }));
            console.debug('createMenuPanel: created', panel.id, 'buttons:', btnInfos);
        } catch (e) { /* ignore */ }

        return panel;
    };

})();

// Thin wrapper to preserve the old createTradingPanel signature while leveraging createMenuPanel
(function(){
    window.createTradingPanel = function(title, playerResources, playerCredits, resourcesPerCredit, tradeValue, repairCost, canRepair, options) {
        try { console.debug('createTradingPanel wrapper called', title); } catch(e) {}
        let sections = [];

        sections.push({
            title: 'INVENTORY',
            rows: [
                {label: 'Resources:', value: `${playerResources} units`},
                {label: 'Credits:', value: `${playerCredits}`}
            ]
        });

        sections.push({
            title: 'TRADE RATES',
            rows: [
                {label: 'Exchange Rate:', value: `${resourcesPerCredit.toFixed(1)} resources/credit`},
                {label: 'Sell Value:', value: `${tradeValue} credits`}
            ]
        });

        sections.push({
            title: 'SERVICES',
            rows: [
                {label: 'Ship Repair:', value: `${repairCost} credits`}
            ],
            extraHtml: '<div style="text-align:center;color:#888;font-size:12px;margin-top:8px;">Ship upgrades and cargo coming soon...</div>'
        });

        let buttons = [];
        if (playerResources > 0) {
            buttons.push({
                label: `[S] Sell Resources (${tradeValue} credits)`,
                onClick: function() { if (U.playerShip && U.playerShip.dockedStation) U.playerShip.dockedStation.sellResources(); }
            });
        }
        if (canRepair) {
            buttons.push({
                label: `[R] Repair Ship (${repairCost} credits)`,
                onClick: function() { if (U.playerShip && U.playerShip.dockedStation) U.playerShip.dockedStation.repairShip(); }
            });
        }
        // Append any extra buttons provided via options (e.g., Mod Bay)
        try {
            if (options && Array.isArray(options.extraButtons)) {
                options.extraButtons.forEach((b, idx) => {
                    let orig = b.onClick || b.action || function() {};
                    let wrapped = function(ev) {
                        try { console.debug('trading-panel: extra button invoked', idx, b && b.label); } catch (e) {}
                        // Immediately dispatch the openModBay event and set a pending station marker
                        try {
                            try { window.__SS_pendingModBayStation = (U && U.playerShip && U.playerShip.dockedStation) || null; } catch (e) {}
                            try { window.dispatchEvent(new CustomEvent('solarspark:openModBay', { detail: { station: (U && U.playerShip && U.playerShip.dockedStation) || null } })); } catch (e) {}
                        } catch (e) {}
                        // Still call the original handler (deferred) in case it contains other logic
                        try { setTimeout(() => { try { orig(ev); } catch (e) { console.error('extraButton handler error', e); } }, 25); } catch (e) { try { orig(ev); } catch (e2) { console.error('extraButton handler fallback error', e2); } }
                    };

                    buttons.push({
                        label: b.label || b.labelText || 'Extra',
                        onClick: wrapped,
                        // Ensure these extra UI hooks do not auto-close the trading panel
                        autoClose: (typeof b.autoClose !== 'undefined') ? b.autoClose : 0
                    });
                });
            }
        } catch (e) { /* ignore */ }
        buttons.push({
            label: `[L] Leave Station`,
            onClick: function() { if (U.playerShip && U.playerShip.dockedStation) U.playerShip.dockedStation.undock(); }
        });

        try {
            let dbgButtons = buttons.map(b => ({ label: b.label, autoClose: b.autoClose, hasOnClick: (typeof b.onClick === 'function') }));
            try { console.debug('createTradingPanel: final buttons', dbgButtons); } catch (e) { console.log('createTradingPanel: final buttons', dbgButtons); }
        } catch (e) {}

        return window.createMenuPanel({
            id: 'trading-panel',
            title: title,
            sections: sections,
            buttons: buttons,
                noClose: 1,
            onClose: function() {
                // Ensure dock state is cleared if trading-panel closed with no undock
                if (U.playerShip && U.playerShip.inTradingInterface && U.playerShip.dockedStation) {
                    // Keep the ship docked but clear the inTradingInterface flag
                    U.playerShip.inTradingInterface = 0;
                }
            }
        });
    };
})();

// Mod Bay panel: allows upgrading ship systems
 (function(){

    // Diagnostic overlay helper - visible marker so the user can see retries even if console is interrupted
    function _modBayShowDiag(attempt) {
        try {
            let id = 'mod-bay-diagnostic';
            let el = document.getElementById(id);
            if (!el) {
                el = document.createElement('div');
                el.id = id;
                el.style.position = 'fixed';
                el.style.right = '12px';
                el.style.top = '12px';
                el.style.zIndex = 12000;
                el.style.padding = '6px 8px';
                el.style.background = 'rgba(255,0,0,0.85)';
                el.style.color = '#fff';
                el.style.fontFamily = 'monospace';
                el.style.fontSize = '12px';
                el.style.borderRadius = '4px';
                el.style.pointerEvents = 'none';
                document.body.appendChild(el);
            }
            el.textContent = 'mod-bay: retry ' + (typeof attempt === 'number' ? attempt : '?') + ' @ ' + (new Date()).toLocaleTimeString();
            // auto-clear after a short period
            try { clearTimeout(el.__mb_clear); } catch (e) {}
            el.__mb_clear = setTimeout(() => { try { el.remove(); } catch (e) {} }, 3000);
        } catch (e) { /* ignore diagnostics failure */ }
    }

    try { console.debug && console.debug('mod-bay:module-init'); } catch (e) {}

    // Utility: calculate upgrade cost for next level (levels start at 1, cost for level N -> N+1 is 50 * 2^(N-1))
    function nextLevelCost(level) {
        // level is current level, cost to reach level+1
        return 50 * Math.pow(2, Math.max(0, level - 1));
    }

    // Utility: calculate attribute multiplier for applying an upgrade of a given level
    // The increase applied when moving from level N to N+1 is:
    // 1->2 : +75% of base
    // 2->3 : +50% of base
    // 3->4 : +25% of base
    // 4->5+ : +20% of base each
    function incrementPercentForLevel(level) {
        let next = level + 1;
        if (next === 2) return 0.75;
        if (next === 3) return 0.5;
        if (next === 4) return 0.25;
        return 0.2;
    }

    // Default list of mod areas and the ship attribute they map to
    let MOD_AREAS = [
        {key: 'hull', label: 'Hull', attr: 'maxHullPoints'},
        {key: 'shield', label: 'Shield', attr: 'maxShieldPoints'},
        {key: 'phasers', label: 'Phasers', attr: 'phaserShots'},
        {key: 'torpedos', label: 'Torpedos', attr: 'torpedoShots'},
        {key: 'thermal', label: 'Thermal Vent', attr: 'thermalRecovery'},
        {key: 'cargo', label: 'Cargo Storage', attr: 'cargoCapacity'}
    ];

    // Ensure player ship has an upgrades object with default levels (1)
    function ensureShipUpgrades(ship) {
        if (!ship.upgrades) ship.upgrades = {};
        MOD_AREAS.forEach(m => { if (typeof ship.upgrades[m.key] !== 'number') ship.upgrades[m.key] = 1; });
    }

    // Apply upgrades to ship stats. We store base values on the ship (baseStats) so we can reapply deterministically.
    function ensureBaseStats(ship) {
                if (!ship.baseStats) {
            ship.baseStats = {
                maxHullPoints: ship.maxHullPoints || 100,
                maxShieldPoints: ship.maxShieldPoints || 100,
                phaserShots: ship.phaserShots || 1,
                torpedoShots: ship.torpedoShots || 1,
                thermalRecovery: ship.thermalRecovery || 1, // lower is faster; we treat as cooldown multiplier
                // Use 200 as the game-default cargo capacity to match trading UI and expectations
                cargoCapacity: (typeof ship.cargoCapacity === 'number' && ship.cargoCapacity > 0) ? ship.cargoCapacity : 200
            };
        }
    }

    function applyUpgradesToShip(ship) {
        ensureShipUpgrades(ship);
        ensureBaseStats(ship);

        // Reset to base
        ship.maxHullPoints = ship.baseStats.maxHullPoints;
        ship.maxShieldPoints = ship.baseStats.maxShieldPoints;
        ship.phaserShots = ship.baseStats.phaserShots;
        ship.torpedoShots = ship.baseStats.torpedoShots;
        ship.thermalRecovery = ship.baseStats.thermalRecovery;
        ship.cargoCapacity = ship.baseStats.cargoCapacity;

        // For each mod area, compute cumulative increases up to current level
        MOD_AREAS.forEach(area => {
            let level = ship.upgrades[area.key] || 1;
            // For each increment from 1..(level-1) apply corresponding percent of base
            let base = ship.baseStats[area.attr] || 0;

            // Special-case Hull and Shield: each level increase grants +20% of the base value per level
            if (area.key === 'hull' || area.key === 'shield') {
                let added = base * 0.2 * Math.max(0, (level - 1));
                // Use rounding for hitpoint-like stats
                ship[area.attr] = Math.max(base, Math.round(ship[area.attr] + added));
            } else if (area.key === 'cargo') {
                // Cargo should follow the 75%/50%/25%/20% pattern per level (cumulative)
                let cumulativeIncrease = 0;
                for (let l = 1; l < level; l++) cumulativeIncrease += incrementPercentForLevel(l);
                let total = Math.round(base * (1 + cumulativeIncrease));
                ship[area.attr] = Math.max(base, total);
            } else {
                // For other areas keep existing cumulative-percent behavior
                let cumulativeIncrease = 0;
                for (let l = 1; l < level; l++) {
                    cumulativeIncrease += incrementPercentForLevel(l);
                }
                let added = base * cumulativeIncrease;

                // Apply addition differently depending on attribute semantics
                if (area.key === 'thermal') {
                    // thermalRecovery is a cooldown; improving vent should reduce cooldown by added percent
                    // We'll treat added as percent of base to subtract
                    ship.thermalRecovery = Math.max(0.01, ship.thermalRecovery - added);
                } else if (area.key === 'phasers' || area.key === 'torpedos') {
                    // Shot counts are integers; round down after applying
                    ship[area.attr] = Math.max(1, Math.floor(ship[area.attr] + added + 0.0001));
                } else {
                    // cargo and others increases directly
                    ship[area.attr] = Math.max(base, ship[area.attr] + added);
                }
            }
        });
    }
    

    // Expose helper to apply upgrades without opening UI (used by restore paths)
    window.applyShipUpgrades = function(ship) {
        try {
            applyUpgradesToShip(ship || U.playerShip);
        } catch (e) { console.error('applyShipUpgrades error', e); }
    };

    // Show the Mod Bay panel for the given station (station is optional, we care about player ship)
    function doOpenModBay(station) {
        try {
            console.debug('doOpenModBay executing for station', station && station.star && station.star.name);
            let ship = U.playerShip;
            ensureShipUpgrades(ship);
            applyUpgradesToShip(ship);

            let sections = [];

            // Top section: credits display
            let credits = ship.credits || 0;
            sections.push({ title: '', html: `<div style="text-align:center;font-weight:bold;margin-bottom:8px;">Credits: <span id="mod-bay-credits">${credits}</span></div>` });

            // Build rows with inline upgrade placeholders
            let rows = MOD_AREAS.map(area => {
                let level = ship.upgrades[area.key] || 1;
                let cost = nextLevelCost(level);
                // For cargo, include a numeric capacity display element we can update
                if (area.key === 'cargo') {
                    return {
                        label: `${area.label} (Level ${level})`,
                        value: `<span class="mod-bay-cost" data-area="${area.key}">${cost} cr</span> <span style="margin-left:8px;"><button type="button" class="mod-bay-upgrade-btn" data-area="${area.key}">Upgrade</button></span>`
                    };
                }

                return {
                    label: `${area.label} (Level ${level})`,
                    // value will be replaced by a span that contains cost and an inline button
                    value: `<span class="mod-bay-cost" data-area="${area.key}">${cost} cr</span> <span style=\"margin-left:8px;\"><button type=\"button\" class=\"mod-bay-upgrade-btn\" data-area=\"${area.key}\">Upgrade</button></span>`
                };
            });

            sections.push({ title: 'Available Upgrades', rows });

            // Create the panel (no separate buttons)
            let panel = window.createMenuPanel({
                id: 'mod-bay-panel',
                title: 'Mod Bay',
                sections,
                noClose: 0,
                buttons: [],
                onClose: () => {
                    try { applyUpgradesToShip(U.playerShip); } catch (e) {}
                }
            });

            // Attach click handlers to inline Upgrade buttons
            try {
                let attachHandler = (btn) => {
                    btn.addEventListener('click', (ev) => {
                        try {
                            let areaKey = btn.getAttribute('data-area');
                            let current = ship.upgrades[areaKey] || 1;
                            let cost = nextLevelCost(current);
                            let preCredits = ship.credits || 0;
                            if (preCredits < cost) {
                                G.showMessage('Not enough credits');
                                return;
                            }

                            // Pre-values for logging
                            let preVals = {
                                maxHullPoints: ship.maxHullPoints,
                                maxShieldPoints: ship.maxShieldPoints,
                                phaserShots: ship.phaserShots,
                                torpedoShots: ship.torpedoShots,
                                thermalRecovery: ship.thermalRecovery,
                                cargoCapacity: ship.cargoCapacity
                            };

                            // Apply purchase
                            ship.credits -= cost;
                            ship.upgrades[areaKey] = current + 1;
                            applyUpgradesToShip(ship);

                            // Update credits display
                            try {
                                let credEl = document.getElementById('mod-bay-credits');
                                if (credEl) credEl.textContent = ship.credits || 0;
                            } catch (e) {}

                            // Update the row's level and cost
                            try {
                                let costEl = panel.querySelector('.mod-bay-cost[data-area="' + areaKey + '"]');
                                if (costEl) {
                                    let newLevel = ship.upgrades[areaKey] || 1;
                                    let newCost = nextLevelCost(newLevel);
                                    costEl.textContent = newCost + ' cr';
                                    // Also update the label text
                                    let rowLabel = costEl.closest('.info-row').querySelector('span');
                                    if (rowLabel) rowLabel.textContent = `${MOD_AREAS.find(a=>a.key===areaKey).label} (Level ${newLevel})`;
                                }
                            } catch (e) {}

                            // If cargo was updated, nothing to refresh in the inline row (capacity badge removed)

                            // Log changes
                            try {
                                let postCredits = ship.credits || 0;
                                let postLevel = ship.upgrades[areaKey] || (current + 1);
                                console.debug('mod-bay: upgrade purchased for', areaKey, 'level', current, '->', postLevel, 'credits', preCredits, '->', postCredits);
                                Object.keys(preVals).forEach(k => {
                                    let before = preVals[k];
                                    let after = ship[k];
                                    if (before !== after) console.debug('mod-bay:', k, 'changed', before, '->', after);
                                    else console.debug('mod-bay:', k, 'unchanged', before);
                                });

                                // Additional explicit debug for Shield, Hull, and Cargo per request
                                try {
                                    if (areaKey === 'shield') {
                                        let beforeShield = preVals.maxShieldPoints;
                                        let afterShield = ship.maxShieldPoints;
                                        console.debug('mod-bay: Shield before -> after:', beforeShield, '->', afterShield);
                                    } else if (areaKey === 'hull') {
                                        let beforeHull = preVals.maxHullPoints;
                                        let afterHull = ship.maxHullPoints;
                                        console.debug('mod-bay: Hull before -> after:', beforeHull, '->', afterHull);
                                    } else if (areaKey === 'cargo') {
                                        let beforeCargo = preVals.cargoCapacity;
                                        let afterCargo = ship.cargoCapacity;
                                        console.debug('mod-bay: Cargo before -> after:', beforeCargo, '->', afterCargo);
                                    }
                                } catch (e) {}
                            } catch (e) {}

                            // Persist state
                            try { if (typeof U !== 'undefined' && typeof U.saveState === 'function') U.saveState(); } catch (e) {}

                        } catch (e) { console.error(e); }
                    });
                };

                let btns = panel.querySelectorAll('.mod-bay-upgrade-btn');
                btns.forEach(b => attachHandler(b));

                // Helper to refresh upgrade button enabled/disabled state based on current credits
                let refreshUpgradeButtons = () => {
                    try {
                        let currentCredits = ship.credits || 0;
                        let btns = panel.querySelectorAll('.mod-bay-upgrade-btn');
                        btns.forEach(b => {
                            try {
                                let areaKey = b.getAttribute('data-area');
                                let level = ship.upgrades[areaKey] || 1;
                                let cost = nextLevelCost(level);
                                if (currentCredits < cost) {
                                    b.setAttribute('disabled', 'disabled');
                                    b.title = 'Not enough credits (' + cost + ' required)';
                                } else {
                                    b.removeAttribute('disabled');
                                    b.title = 'Upgrade for ' + cost + ' credits';
                                }
                            } catch (e) {}
                        });
                        // Also refresh displayed cargo capacity if present
                        // capacity badge removed; no-op
                    } catch (e) {}
                };

                // Initial refresh
                refreshUpgradeButtons();

                // Keep buttons refreshed while panel is open. Prefer event-driven updates via G.eventHub
                // but fall back to a poll interval if the hub isn't available.
                let __mb_refresh_interval;
                let originalOnClose = panel.onClose || (() => {});

                // Style and tooltip for cargo capacity badge (small, faded, and show next-level capacity/cost)
                // capacity badge removed; no tooltip to set

                // Use event listeners where possible
                let creditsListener = null;
                let cargoListener = null;
                try {
                    if (window.G && G.eventHub && typeof G.eventHub.listen === 'function') {
                        creditsListener = function() { try { refreshUpgradeButtons(); } catch (e) {} };
                        cargoListener = function() { try { refreshUpgradeButtons(); } catch (e) {} };
                        try { G.eventHub.listen('player:creditsChanged', creditsListener); } catch (e) {}
                        try { G.eventHub.listen('player:cargoCapacityChanged', cargoListener); } catch (e) {}
                    } else {
                        // fallback to polling
                        __mb_refresh_interval = setInterval(refreshUpgradeButtons, 500);
                    }
                } catch (e) {
                    __mb_refresh_interval = setInterval(refreshUpgradeButtons, 500);
                }

                // Ensure listeners/interval are cleared when panel is closed
                panel.onClose = () => {
                    try { if (creditsListener && G.eventHub && typeof G.eventHub.ignore === 'function') G.eventHub.ignore('player:creditsChanged', creditsListener); } catch (e) {}
                    try { if (cargoListener && G.eventHub && typeof G.eventHub.ignore === 'function') G.eventHub.ignore('player:cargoCapacityChanged', cargoListener); } catch (e) {}
                    try { clearInterval(__mb_refresh_interval); } catch (e) {}
                    try { originalOnClose(); } catch (e) {}
                };
            } catch (e) { /* ignore UI attach errors */ }

            // Make the panel wide so buttons can fit (and visually consistent with request)
            try { panel.style.minWidth = '640px'; panel.style.maxWidth = '80%'; } catch (e) {}

            return 1;
        } catch (e) { console.error('doOpenModBay error', e); return 0; }
    }

    // Try opening mod bay with retries to survive occasional synchronous extension errors
    function tryOpenModBay(station, attempt) {
        try {
            try { console.debug('mod-bay: tryOpenModBay', attempt); } catch (e) {}
            _modBayShowDiag(attempt);
            if (doOpenModBay(station)) {
                try { console.debug('mod-bay: opened on attempt', attempt); } catch (e) {}
                return;
            }
        } catch (e) {
            try { console.error('mod-bay: tryOpenModBay caught', e && e.stack ? e.stack : e); } catch (e2) {}
        }
        if (attempt >= 4) return;
        setTimeout(() => tryOpenModBay(station, attempt + 1), 60 * (attempt + 1));
    }

    window.openModBay = function(station) {
        try {
            console.debug('mod-bay: window.openModBay called');
            _modBayShowDiag(0);
            setTimeout(() => tryOpenModBay(station, 0), 0);
        } catch (e) {
            try { console.error('mod-bay: openModBay fallback error', e && e.stack ? e.stack : e); } catch (e2) {}
            tryOpenModBay(station, 0);
        }
    };

    // Also listen for a CustomEvent dispatched by UI wrappers (decoupled open)
    try {
        // Mark module as loaded
        try { window.__SS_modBayLoaded = 1; } catch (e) {}

        window.addEventListener('solarspark:openModBay', (ev) => {
            try { console.debug('solarspark:openModBay event received', ev && ev.detail); } catch (e) {}
            try { _modBayShowDiag(0); } catch (e) {}
            tryOpenModBay(ev && ev.detail && ev.detail.station, 0);
        });

        // If a station dispatched the open event before this module loaded, handle it
        try {
            if (window.__SS_pendingModBayStation) {
                try { console.debug('mod-bay: found pending station on load', window.__SS_pendingModBayStation); } catch (e) {}
                let st = window.__SS_pendingModBayStation;
                try { delete window.__SS_pendingModBayStation; } catch (e) { window.__SS_pendingModBayStation = null; }
                tryOpenModBay(st, 0);
            }
        } catch (e) { /* ignore */ }
    } catch (e) {}

})();

// Wrapper to create a Planetary Trade panel using createMenuPanel
(function(){
    // Clean, shared message constants to avoid accidental hidden characters in literals
    let NO_CARGO_SPACE_MSG = 'Not enough credits or cargo space';
    // Compute and persist a price for a cargo item on a per-planet basis (base value +/-20%)
    function getPlanetPrice(planet, cargoName) {
        try {
            if (!planet) return 1;
            if (!planet.prices) planet.prices = {};
            if (planet.prices[cargoName] !== undefined) return planet.prices[cargoName];

            // Lookup the cargo base value from CARGO_DATA
            let base = 1;
            try {
                if (typeof CARGO_DATA !== 'undefined' && Array.isArray(CARGO_DATA)) {
                    let def = CARGO_DATA.find(d => d.cargo === cargoName || String(d.id) === String(cargoName));
                    if (def && def.value) base = def.value;
                }
            } catch (e) {}

            let variance = 0.8 + Math.random() * 0.4; // 0.8 - 1.2
            let price = Math.max(1, Math.round(base * variance));
            planet.prices[cargoName] = price;
            return price;
        } catch (e) { return 1; }
    }

    // Helper to create sample planet cargo offerings
    function samplePlanetCargo(planet) {
        // If CARGO_DATA is available, pick 3 unique random entries and generate units/price
        let picks = [];
        try {
            if (typeof CARGO_DATA !== 'undefined' && Array.isArray(CARGO_DATA) && CARGO_DATA.length) {
                // Shuffle indexes and take first 3
                let idx = CARGO_DATA.map((_, i) => i);
                for (let i = idx.length - 1; i > 0; i--) {
                    let j = Math.floor(Math.random() * (i + 1));
                    let t = idx[i]; idx[i] = idx[j]; idx[j] = t;
                }
                let take = Math.min(3, idx.length);
                for (let k = 0; k < take; k++) {
                    let item = CARGO_DATA[idx[k]];
                    let units = 100 + Math.floor(Math.random() * 901); // 100-1000
                    let price = getPlanetPrice(planet, item.cargo);
                    picks.push({ name: item.cargo, units, price });
                }
                return picks;
            }
        } catch (e) {
            console.error('samplePlanetCargo using fallback due to error', e);
        }

        // Fallback simple sample
        let cargoTypes = ['Food', 'Minerals', 'Medicine', 'Textiles', 'Electronics', 'Spices'];
        for (let i = 0; i < 3; i++) {
            let name = cargoTypes[(i + (planet.name ? planet.name.length : 0)) % cargoTypes.length];
            let units = 100 + Math.floor(Math.random() * 901);
            let price = Math.max(1, Math.floor(5 + i * 3 + (Math.random() * 5)));
            picks.push({ name, units, price });
        }
        return picks;
    }

    // Compute player's inventory entries (if ship.cargo map exists), otherwise fall back to generic resources
    function playerInventoryEntries(ship, planet) {
        let entries = [];
        if (!ship) return entries;

        if (ship.cargo && typeof ship.cargo === 'object' && Object.keys(ship.cargo).length) {
            Object.keys(ship.cargo).forEach(k => {
                let units = ship.cargo[k] || 0;
                if (!units || units <= 0) return; // skip zero-unit entries
                let price = Math.max(1, Math.floor(3 + (Math.random() * 5)));
                try {
                    if (planet) {
                        price = getPlanetPrice(planet, k);
                    }
                } catch (e) {}
                entries.push({ name: k, units: units, price });
            });
        } else if (ship.civilization && ship.civilization.resources) {
            entries.push({ name: 'Raw Materials', units: ship.civilization.resources, price: 1 });
        }

        return entries;
    }

    function getCargoDefByName(name) {
        try {
            if (typeof CARGO_DATA !== 'undefined' && Array.isArray(CARGO_DATA)) {
                return CARGO_DATA.find(i => i.cargo === name || i.id === name || String(i.id) === String(name));
            }
        } catch (e) {}
        return null;
    }

    function getShipUsedSpace(ship) {
        if (!ship) return 0;
        if (!ship.cargo) return 0;
        let used = 0;
        Object.keys(ship.cargo).forEach(name => {
            let def = getCargoDefByName(name);
            let units = ship.cargo[name] || 0;
            let per = def && def.storage_units ? def.storage_units : 1;
            used += units * per;
        });
        return used;
    }

    function getShipRemainingSpace(ship) {
        let CAP = (ship && typeof ship.cargoCapacity === 'number' && ship.cargoCapacity > 0) ? ship.cargoCapacity : 200;
        return Math.max(0, CAP - getShipUsedSpace(ship));
    }

    window.createPlanetaryTradePanel = function(planet, ship) {
        try { console.debug('createPlanetaryTradePanel called', planet && planet.name); } catch(e) {}

        ensureCreateMenuPanelExists();

        // If a ship is provided, set docking-like state so the ship locks to the planet and becomes invulnerable
        try {
            if (ship && planet) {
                // mark as docked to planet
                ship.dockedPlanet = planet;
                ship.isDocked = 1;
                ship.inTradingInterface = 1;
                // compute dock offset based on current angle from planet to ship
                let angleToShip = angleBetween(planet, ship);
                let dockDistance = planet.radius + 15;
                ship.dockOffset = { x: Math.cos(angleToShip) * dockDistance, y: Math.sin(angleToShip) * dockDistance };
                // ensure credits present
                if (ship.credits === undefined) ship.credits = 0;
            }
        } catch (e) { console.error('planetary-trade: failed to set dock state', e); }

        // Persist market on planet
        if (!planet.market) {
            planet.market = samplePlanetCargo(planet || {});
        }
    let planetOfferings = planet.market;
    let playerEntries = playerInventoryEntries(ship || {}, planet);

        // Build sections: Cargo (planet offerings) then Inventory (player)
        let sections = [];

        // Planet Cargo section (big list)
        // Include an inline message placeholder (.panel-message) so we can display errors inside the panel
        let cargoHtml = '<div class="section">';
    cargoHtml += '<h3>CARGO FOR SALE</h3>';
        planetOfferings.forEach((c, i) => {
            cargoHtml += `<div class="info-row" data-market-index="${i}"><span>${c.name} (${c.units} units)</span><span>${c.price} cr/unit</span></div>`;
        });
        cargoHtml += '</div>';
        sections.push({ html: cargoHtml });

        // Player inventory section
        // Inventory section will be populated dynamically after panel creation so we can attach
        // interactive Sell buttons and tooltips. Start with an empty section placeholder.
        sections.push({ title: 'INVENTORY', rows: [] });

        // Buttons: Leave button
        let buttons = [];
        buttons.push({
            label: '[L] Leave',
            onClick: function() { if (window.planetaryUndock) window.planetaryUndock(); }
        });

        // Create panel
        let panel = window.createMenuPanel({
            id: 'planetary-trade-panel',
            title: (planet && planet.name ? planet.name : 'Unknown') + ' - Planetary Trade',
            sections: sections,
            buttons: buttons,
            noClose: 1,
            onClose: function() { if (window.planetaryUndock) window.planetaryUndock(); }
        });

        // Insert a header-level panel message element under the title for inline messages
        try {
                    if (panel) {
                let titleEl = panel.querySelector('h2');
                if (titleEl && !panel.querySelector('.panel-message')) {
                    let headerMsg = document.createElement('div');
                    headerMsg.className = 'panel-message';
                    titleEl.insertAdjacentElement('afterend', headerMsg);
                }
            }
        } catch (e) { /* ignore */ }

        // Helper to set panel header message and auto-clear it on timeout or interaction
        let panelMsgTimeout = null;
        function setPanelMessage(text) {
            try {
                if (!panel) return;
                let pm = panel.querySelector('.panel-message');
                if (!pm) return;
                pm.textContent = text || '';

                // Clear any previous timer
                if (panelMsgTimeout) {
                    clearTimeout(panelMsgTimeout);
                    panelMsgTimeout = null;
                }

                if (text) {
                    // Auto-clear after 3.5 seconds
                    panelMsgTimeout = setTimeout(() => {
                        try { pm.textContent = ''; } catch (e) {}
                        panelMsgTimeout = null;
                    }, 3500);
                }
            } catch (e) { /* ignore */ }
        }

        // Clear panel message when user interacts inside the panel (click or keydown)
        try {
            if (panel) {
                panel.addEventListener('click', () => { if (panelMsgTimeout) { clearTimeout(panelMsgTimeout); panelMsgTimeout = null; } let pm = panel.querySelector('.panel-message'); if (pm) pm.textContent = ''; });
                panel.addEventListener('keydown', () => { if (panelMsgTimeout) { clearTimeout(panelMsgTimeout); panelMsgTimeout = null; } let pm = panel.querySelector('.panel-message'); if (pm) pm.textContent = ''; });
            }
        } catch (e) { /* ignore */ }

        // Create a single shared price tooltip element attached to the panel. Using one shared tooltip
        // avoids tooltip elements lingering when moving between price elements.
        try {
            if (panel && !panel.querySelector('.price-tooltip')) {
                let sharedTooltip = document.createElement('div');
                sharedTooltip.className = 'price-tooltip';
                panel.appendChild(sharedTooltip);
            }
        } catch (e) { /* ignore */ }

        // Attach Buy buttons for planet offerings and Sell buttons for player inventory
        try {
            let firstSection = panel.querySelector('.section'); // planet offerings
            let invSection = panel.querySelector('.section + .section'); // second section is inventory

            // Add remaining cargo capacity indicator in the header area
            let capacityIndicator = document.createElement('div');
            capacityIndicator.className = 'capacity-indicator';
            let remainingSpaceVal = getShipRemainingSpace(ship);
            // Show the ship's total capacity as well to make upgrades obvious
            let totalCap = (ship && typeof ship.cargoCapacity === 'number' && ship.cargoCapacity > 0) ? ship.cargoCapacity : 200;
            capacityIndicator.textContent = `Ship cargo remaining: ${remainingSpaceVal} / ${totalCap} units`;
            // Also show ship credits above the listings
            let creditsIndicator = document.createElement('div');
            creditsIndicator.className = 'credits-indicator';
            creditsIndicator.textContent = `Ship credits: ${ship && ship.credits ? ship.credits : 0} cr`;
            // Show reputation with this planet if available
            let reputationIndicator = document.createElement('div');
            reputationIndicator.className = 'reputation-indicator';
            try {
                let rep = planet && planet.civilization && typeof planet.civilization.reputation === 'number' ? planet.civilization.reputation : 0;
                let sign = rep > 0 ? '+' : '';
                reputationIndicator.textContent = `Reputation: ${sign}${rep}`;
            } catch (e) { reputationIndicator.textContent = 'Reputation: 0'; }
            if (firstSection) {
                firstSection.insertBefore(creditsIndicator, firstSection.firstChild);
                firstSection.insertBefore(capacityIndicator, creditsIndicator.nextSibling);
                firstSection.insertBefore(reputationIndicator, capacityIndicator.nextSibling);
            }

            // Attach Buy controls next to each market row
            if (firstSection) {
                let rows = firstSection.querySelectorAll('.info-row');
                rows.forEach(row => {
                    let idx = parseInt(row.getAttribute('data-market-index'), 10);

                    // Replace the price text with a price element that shows a tooltip on hover
                    try {
                        let spans = row.querySelectorAll('span');
                        let priceSpan = spans && spans[1];
                        if (priceSpan) {
                            let marketItem = planetOfferings[idx];
                            let priceEl = document.createElement('span');
                            priceEl.className = 'price-el';
                            priceEl.style.marginLeft = '8px';
                            priceEl.style.fontWeight = 'bold';
                            priceEl.textContent = (marketItem && marketItem.price ? marketItem.price : 0) + ' cr/unit';

                            function formatTooltip(cargoName, price) {
                                let def = getCargoDefByName(cargoName) || {};
                                let base = def.value || price || 1;
                                let pct = Math.round((price - base) / base * 100);
                                let pctText = '';
                                if (pct === 0) {
                                    pctText = '';
                                } else if (pct > 0) {
                                    pctText = '+' + pct + '%';
                                } else {
                                    pctText = pct + '%';
                                }

                                // Build tooltip DOM with colored percent span
                                // For planet offerings: a lower price (negative pct) is good for the player,
                                // so negative percentages should be blue/green. Positive pct (more expensive)
                                // should be highlighted as yellow/orange.
                                let color = '#fff';
                                if (pct < 0) {
                                    if (pct <= -11) color = '#66ff66'; // green (very cheap)
                                    else color = '#66c2ff'; // blue (cheap)
                                } else if (pct > 0) {
                                    if (pct >= 11) color = '#ff9900'; // orange (very expensive)
                                    else color = '#ffd700'; // yellow (expensive)
                                }

                                if (pct === 0) {
                                    return `${base} = ${price}`;
                                }

                                // Example: "45+19%=54" with percent colored
                                // We'll wrap the percent in a span so we can color it
                                return `<span>${base}</span><span style=\"margin:0 6px;color:${color};\">${pctText}</span><span>=${price}</span>`;
                            }

                            // Mouse handlers
                            let hideTimer = null;
                            priceEl.addEventListener('mouseenter', (ev) => {
                                try { ev.stopPropagation(); } catch (e) {}
                                if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
                                let marketItemNow = planetOfferings[idx];
                                let price = marketItemNow && marketItemNow.price ? marketItemNow.price : 0;
                                let t = panel.querySelector('.price-tooltip');
                                if (!t) return;
                                t.innerHTML = formatTooltip(marketItemNow && marketItemNow.name, price);
                                t.style.display = 'block';
                                let rect = panel.getBoundingClientRect();
                                t.style.left = Math.min(panel.clientWidth - 10, (ev.pageX - rect.left) + 12) + 'px';
                                t.style.top = Math.max(6, (ev.pageY - rect.top) - 24) + 'px';
                            });
                            priceEl.addEventListener('mousemove', (ev) => {
                                try { ev.stopPropagation(); } catch (e) {}
                                let t = panel.querySelector('.price-tooltip');
                                if (!t) return;
                                let rect = panel.getBoundingClientRect();
                                t.style.left = Math.min(panel.clientWidth - 10, (ev.pageX - rect.left) + 12) + 'px';
                                t.style.top = Math.max(6, (ev.pageY - rect.top) - 24) + 'px';
                            });
                            priceEl.addEventListener('mouseleave', (ev) => {
                                try { ev.stopPropagation(); } catch (e) {}
                                let t = panel.querySelector('.price-tooltip');
                                if (!t) return;
                                if (hideTimer) clearTimeout(hideTimer);
                                hideTimer = setTimeout(() => { t.style.display = 'none'; hideTimer = null; }, 50);
                            });

                            // Replace original price span with interactive one
                            priceSpan.parentNode.replaceChild(priceEl, priceSpan);
                        }
                    } catch (e) { /* ignore tooltip injection errors */ }

                    let controls = document.createElement('span');
                    controls.className = 'controls';

                    let buyBtn = document.createElement('button');
                    // Ensure button does not act as a form submit and avoid bubbling to page-level handlers/extensions
                    buyBtn.type = 'button';
                    buyBtn.textContent = 'Buy';

                    // Inline quantity UI (hidden initially)
                    let qtyWrapper = document.createElement('span');
                    qtyWrapper.className = 'qty-wrapper';

                    let minus = document.createElement('button');
                    minus.textContent = '-';
                    minus.className = 'qty-minus';
                    let qtyInput = document.createElement('input');
                    qtyInput.type = 'number';
                    qtyInput.value = '1';
                    qtyInput.min = '1';
                    qtyInput.className = 'qty-input';
                    let plus = document.createElement('button');
                    plus.textContent = '+';
                    plus.className = 'qty-plus';

                    let maxBtn = document.createElement('button');
                    maxBtn.textContent = 'Max';
                    maxBtn.className = 'qty-max';

                    let confirmBtn = document.createElement('button');
                    confirmBtn.textContent = 'Confirm';
                    confirmBtn.className = 'qty-confirm';
                    let cancelBtn = document.createElement('button');
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.className = 'qty-cancel';

                    qtyWrapper.appendChild(minus);
                    qtyWrapper.appendChild(qtyInput);
                    qtyWrapper.appendChild(plus);
                    qtyWrapper.appendChild(maxBtn);
                    qtyWrapper.appendChild(confirmBtn);
                    qtyWrapper.appendChild(cancelBtn);

                    // Handlers
                        buyBtn.addEventListener('click', (ev) => {
                            try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch (e) {}
                        let marketItem = planetOfferings[idx];
                        if (!marketItem || marketItem.units <= 0) {
                            if (typeof setPanelMessage === 'function') setPanelMessage('Item out of stock'); else { let panelMsg = panel.querySelector('.panel-message'); if (panelMsg) { panelMsg.textContent = 'Item out of stock'; } else { G.showMessage('Item out of stock'); } }
                            return;
                        }

                        let maxByStock = marketItem.units;
                        let maxByCredits = Math.floor((ship.credits || 0) / marketItem.price);
                        let remainingSpace = getShipRemainingSpace(ship);
                        let def = getCargoDefByName(marketItem.name);
                        let perUnitSpace = def && def.storage_units ? def.storage_units : 1;
                        let maxBySpace = Math.floor(remainingSpace / perUnitSpace);
                        let maxAllowed = Math.max(0, Math.min(maxByStock, maxByCredits, maxBySpace));

                        if (maxAllowed <= 0) {
                            if (typeof setPanelMessage === 'function') setPanelMessage(NO_CARGO_SPACE_MSG); else { let panelMsg = panel.querySelector('.panel-message'); if (panelMsg) { panelMsg.textContent = NO_CARGO_SPACE_MSG; } else { G.showMessage(NO_CARGO_SPACE_MSG); } }
                            return;
                        }

                        // Show quantity controls and set limits
                        qtyInput.max = String(maxAllowed);
                        qtyInput.value = '1';
                        qtyWrapper.classList.add('open');
                        buyBtn.classList.add('hidden');

                        // Wire quantity controls with event suppression
                        minus.type = 'button';
                        plus.type = 'button';
                        maxBtn.type = 'button';
                        cancelBtn.type = 'button';
                        confirmBtn.type = 'button';

                        minus.addEventListener('click', (ev) => { try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e){}; qtyInput.value = String(Math.max(1, parseInt(qtyInput.value || '1', 10) - 1)); });
                        plus.addEventListener('click', (ev) => { try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e){}; qtyInput.value = String(Math.min(maxAllowed, parseInt(qtyInput.value || '1', 10) + 1)); });
                        maxBtn.addEventListener('click', (ev) => { try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e){}; qtyInput.value = String(maxAllowed); });

                        cancelBtn.addEventListener('click', (ev) => {
                            try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e){}
                            qtyWrapper.classList.remove('open');
                            buyBtn.classList.remove('hidden');
                        });

                        confirmBtn.addEventListener('click', (ev) => {
                            try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e){}
                            let qty = Math.max(0, Math.min(parseInt(qtyInput.value, 10) || 0, parseInt(qtyInput.max, 10) || 0));
                            if (qty <= 0) return;

                            let cost = qty * marketItem.price;
                            ship.credits = (ship.credits || 0) - cost;
                            ship.cargo = ship.cargo || {};
                            ship.cargo[marketItem.name] = (ship.cargo[marketItem.name] || 0) + qty;
                            marketItem.units -= qty;

                            G.showMessage('Purchased ' + qty + ' ' + marketItem.name + ' for ' + cost + ' credits');

                            // Refresh the panel
                            panel.remove();
                            window.createPlanetaryTradePanel(planet, ship);
                        });
                    });

                    controls.appendChild(buyBtn);
                    controls.appendChild(qtyWrapper);
                    row.appendChild(controls);
                });
            }

            if (invSection) {
                let entries = playerEntries;

                // Remove any existing informational rows in the inventory section to avoid duplicates
                try {
                    let existingRows = invSection.querySelectorAll('.info-row');
                    existingRows.forEach(r => r.remove());
                } catch (e) { /* ignore */ }
                entries.forEach((pe, i) => {
                    // Create price element with hover tooltip for comparison
                    try {
                        let priceEl = document.createElement('span');
                        priceEl.className = 'inv-price-el';
                        priceEl.textContent = `${pe.price} cr/unit`;

                        // Tooltip handlers (reuse logic similar to market rows)
                        priceEl.addEventListener('mouseenter', (ev) => {
                            try { ev.stopPropagation(); } catch (e) {}
                            let t = panel.querySelector('.price-tooltip') || (function(){
                                let tmp = document.createElement('div');
                                tmp.className = 'price-tooltip';
                                tmp.style.position = 'absolute';
                                tmp.style.pointerEvents = 'none';
                                tmp.style.background = 'rgba(0,0,0,0.85)';
                                tmp.style.color = '#fff';
                                tmp.style.padding = '6px 8px';
                                tmp.style.borderRadius = '4px';
                                tmp.style.fontSize = '12px';
                                tmp.style.zIndex = 9999;
                                tmp.style.display = 'none';
                                tmp.style.whiteSpace = 'nowrap';
                                panel.appendChild(tmp);
                                return tmp;
                            })();
                            let def = getCargoDefByName(pe.name) || {};
                            let base = def.value || pe.price || 1;
                            let pct = Math.round((pe.price - base) / base * 100);
                            let color = '#fff';
                            if (pct < 0) {
                                color = pct <= -11 ? '#ff9900' : '#ffd700';
                            } else if (pct > 0) {
                                color = pct >= 11 ? '#66ff66' : '#66c2ff';
                            }
                            let pctText = pct === 0 ? '' : (pct > 0 ? '+' + pct + '%' : pct + '%');
                            if (pct === 0) {
                                t.innerHTML = `${base} = ${pe.price}`;
                            } else {
                                t.innerHTML = `<span>${base}</span><span style=\"margin:0 6px;color:${color};\">${pctText}</span><span>=${pe.price}</span>`;
                            }
                            t.style.display = 'block';
                            let rect = panel.getBoundingClientRect();
                            t.style.left = Math.min(panel.clientWidth - 10, (ev.pageX - rect.left) + 12) + 'px';
                            t.style.top = Math.max(6, (ev.pageY - rect.top) - 24) + 'px';
                        });
                        priceEl.addEventListener('mousemove', (ev) => {
                            try { ev.stopPropagation(); } catch (e) {}
                            let t = panel.querySelector('.price-tooltip');
                            if (!t) return;
                            let rect = panel.getBoundingClientRect();
                            t.style.left = Math.min(panel.clientWidth - 10, (ev.pageX - rect.left) + 12) + 'px';
                            t.style.top = Math.max(6, (ev.pageY - rect.top) - 24) + 'px';
                        });
                        priceEl.addEventListener('mouseleave', (ev) => {
                            try { ev.stopPropagation(); } catch (e) {}
                            let t = panel.querySelector('.price-tooltip');
                            if (t) t.style.display = 'none';
                        });
                        // Append the price element plus Sell button to the inventory section row
                        let row = document.createElement('div');
                        row.className = 'info-row';
                        row.innerHTML = `<span>${pe.name} (${pe.units} units)</span>`;
                        row.appendChild(priceEl);

                        let sellBtn = document.createElement('button');
                        sellBtn.type = 'button';
                        sellBtn.textContent = `Sell ${pe.name}`;
                        sellBtn.className = 'sell-btn';
                        // Prevent mousedown from bubbling to avoid extension/content-script side effects
                        sellBtn.addEventListener('mousedown', (ev) => { try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e) {} });
                        sellBtn.addEventListener('click', (ev) => {
                            try { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); } catch(e) {}
                            let units = pe.units || 0;
                            let total = units * pe.price;
                            if (units > 0) {
                                if (ship.cargo && ship.cargo[pe.name] !== undefined) {
                                    // Remove the cargo key entirely so inventory reflects the removal
                                    try { delete ship.cargo[pe.name]; } catch (e) { ship.cargo[pe.name] = 0; }
                                } else if (ship.civilization && ship.civilization.resources) {
                                    ship.civilization.resources = 0;
                                }
                                ship.credits = (ship.credits || 0) + total;
                                G.showMessage('Sold ' + units + ' ' + pe.name + ' for ' + total + ' credits');
                                panel.remove();
                                window.createPlanetaryTradePanel(planet, ship);
                            }
                        });
                        row.appendChild(sellBtn);
                        invSection.appendChild(row);
                    } catch (e) { /* ignore inventory tooltip/sell UI errors */ }

                });
            }
        } catch (e) { console.error('planetary-trade: failed to attach sell buttons', e); }

        return panel;
    };

    // Provide a global undock function for planetary trade
    window.planetaryUndock = function() {
        try {
            let p = document.getElementById('planetary-trade-panel');
            if (p) p.remove();
            if (U && U.playerShip) {
                U.playerShip.dockedPlanet = null;
                U.playerShip.isDocked = 0;
                U.playerShip.inTradingInterface = 0;
                U.playerShip.dockOffset = null;
            }
        } catch (e) { console.error('planetaryUndock error', e); }
    };

    // Small helper to ensure createMenuPanel is available; if not, no-op but avoid crash
    function ensureCreateMenuPanelExists() {
        if (!window.createMenuPanel) {
            window.createMenuPanel = function() {
                console.warn('createMenuPanel not found - Planetary trade unavailable');
                return null;
            };
        }
    }

})();

class OrbitalStation {

    constructor(star, orbitRadius, orbitPhase) {
        this.star = star;
        this.orbitRadius = orbitRadius;
        this.orbitPhase = orbitPhase;
        this.radius = 60; // About 1/3 planet size (planets are ~150-200)
        this.reachRadius = this.radius * 3;
        
        this.health = 1;
        this.lastDamage = 0;
        this.showingDockPrompt = 0;
        
        // Trading properties - 10 resources (±3) per 1 credit
        let baseRate = 10; // 10 resources per credit
        let variation = (Math.random() - 0.5) * 6; // ±3 variation
        this.resourcesPerCredit = baseRate + variation; // 7-13 resources per credit
        this.tradeRate = 1 / this.resourcesPerCredit; // credits per resource
        
        // Create a neutral civilization for the station
        this.civilization = new Civilization(this, 0.5);
        
        this.updatePosition();
    }

    updatePosition() {
        this.x = this.star.x + cos(this.orbitPhase) * this.orbitRadius;
        this.y = this.star.y + sin(this.orbitPhase) * this.orbitRadius;
    }

    cycle(e) {
        // Orbit around the star more slowly than planets
        let yearTime = TWO_PI * this.orbitRadius / 15; // Half speed of planets
        let angularVelocity = TWO_PI / yearTime;
        this.orbitPhase += e * angularVelocity;
        
        this.updatePosition();
        
        // Check for docking proximity (4 ship lengths = ~120 units)
        let dockingDistance = 120;
        let playerDistance = dist(this, U.playerShip);
        
        if (playerDistance < dockingDistance && !this.showingDockPrompt) {
            this.showingDockPrompt = 1;
            // Compute Station title for HUD while approaching
            let title = (this.star && this.star.name ? this.star.name : 'Unknown') + ' - Station - 1';
            try {
                if (U && U.orbitalStations) {
                    let siblings = U.orbitalStations.filter(s => s.star === this.star);
                    let index = siblings.indexOf(this) + 1 || 1;
                    title = (this.star && this.star.name ? this.star.name : 'Unknown') + ' - Station - ' + index;
                }
            } catch (e) {
                // ignore and fall back to default title
            }

            G.showPrompt(`${title}\nPress [D] to dock`);
        } else if (playerDistance >= dockingDistance && this.showingDockPrompt) {
            this.showingDockPrompt = 0;
            G.showPrompt();
        }
    }

    render() {
        // Always draw white orbital ring (like planets do)
        translate(this.star.x, this.star.y);
        R.strokeStyle = '#fff';
        R.lineWidth = 1;
        R.globalAlpha = 0.3;
        beginPath();
        arc(0, 0, this.orbitRadius, 0, TWO_PI);
        stroke();
        R.globalAlpha = 1;

        // Only draw the station itself if visible
        if (!V.isVisible(this, this.radius)) {
            return;
        }

        translate(this.x - this.star.x, this.y - this.star.y);
        
        let damageFactor = 1 - limit(0, G.clock - this.lastDamage, 0.1) / 0.1;
        scale(1 + damageFactor * 0.2, 1 + damageFactor * 0.2);

        // Color based on relationship and damage
        let color = damageFactor > 0 ? '#fff' : 
            (this.civilization.relationshipType() === '#f00' ? '#f00' : 
             (this.civilization.relationshipType() === '#0f0' ? '#0f0' : '#ff0'));
        
        fs(color);
        R.lineWidth = 4;
        
        // Draw larger triangular station
        beginPath();
        moveTo(0, -30);
        lineTo(-26, 20);
        lineTo(26, 20);
        closePath();
        fill();
        stroke();
        
        // Draw center core
        fs('#888');
        beginPath();
        arc(0, 0, 8, 0, TWO_PI);
        fill();
    }

    damage(source, amount) {
        if (this.isDocked) return; // Invulnerable while docked
        if (source.owner == U.playerShip) {
            particle('#ff0', [
                ['alpha', 1, 0, 1],
                ['size', rnd(2, 4), rnd(5, 10), 1],
                ['x', this.x, this.x + rnd(-20, 20), 1],
                ['y', this.y, this.y + rnd(-20, 20), 1]
            ]);

            this.lastDamage = G.clock;
            this.civilization.updateRelationship(-0.05);
            this.civilization.wasAttackedByPlayer = 1;

            if ((this.health -= amount) <= 0) {
                this.explode(source);
            }
        }
    }

    dock() {
        console.log("Dock method called");
        
        // Clear the prompt
        G.showPrompt();
        
        // Connect ship to station - position ship touching the station
        U.playerShip.dockedStation = this;
        U.playerShip.isDocked = 1;
        U.playerShip.inTradingInterface = 1;
        
        console.log("Ship docked, isDocked:", U.playerShip.isDocked);
        
        // Initialize player credits if not set
        if (U.playerShip.credits === undefined) {
            U.playerShip.credits = 0;
        }
        
        // Calculate angle from station to ship
        let angleToShip = angleBetween(this, U.playerShip);
        
        // Position ship at station edge (station radius + small gap)
        let dockDistance = this.radius + 15; // Small gap for visual clarity
        U.playerShip.dockOffset = {
            x: cos(angleToShip) * dockDistance,
            y: sin(angleToShip) * dockDistance
        };
        
        console.log("About to show trading interface");
        
        // Show trading interface
        this.showTradingInterface();
    }
    
    showTradingInterface() {
        let playerResources = U.playerShip.civilization ? U.playerShip.civilization.resources : 0;
        let playerCredits = U.playerShip.credits || 0;
        let tradeValue = Math.floor(playerResources * this.tradeRate);
        let repairCost = 20;
        let canRepair = playerCredits >= repairCost && (U.playerShip.health < 1 || U.playerShip.shield < 1);
        
        // Compute station index within this star's orbital stations (1-based)
        let index = 1;
        try {
            if (U && U.orbitalStations) {
                let siblings = U.orbitalStations.filter(s => s.star === this.star);
                index = siblings.indexOf(this) + 1 || 1;
            }
        } catch (e) {
            index = 1;
        }

    let title = (this.star && this.star.name ? this.star.name : 'Unknown') + ' - Station - ' + index;
        
        // Use the global function to create the panel (now accepts a title first)
        if (window.createTradingPanel) {
            window.createTradingPanel(title, playerResources, playerCredits, this.resourcesPerCredit, tradeValue, repairCost, canRepair, {
                // Provide a hook for additional buttons in the trading panel UI
                extraButtons: [{
                        label: 'Mod Bay',
                        onClick: () => {
                            try {
                                // Mark the station as pending (fallback) and dispatch a CustomEvent so
                                // opening the Mod Bay is decoupled from direct function calls that
                                // some extensions/content-scripts may interfere with.
                                try { window.__SS_pendingModBayStation = this; } catch (e) {}
                                window.dispatchEvent(new CustomEvent('solarspark:openModBay', { detail: { station: this } }));

                                // Poll for the mod-bay module being loaded; if it appears, call openModBay
                                // as a fallback. This helps when the event was dispatched before the
                                // mod-bay listener attached.
                                try {
                                    let attempts = 0;
                                    let poll = setInterval(() => {
                                        try {
                                            attempts++;
                                            if (window.__SS_modBayLoaded && typeof window.openModBay === 'function') {
                                                try { console.debug('station: polling detected mod-bay loaded, calling openModBay', attempts); } catch (e) {}
                                                try { window.openModBay(this); } catch (e) { console.error('station: fallback openModBay error', e); }
                                                clearInterval(poll);
                                                try { delete window.__SS_pendingModBayStation; } catch (e) { window.__SS_pendingModBayStation = null; }
                                                return;
                                            }
                                            if (attempts > 8) { clearInterval(poll); }
                                        } catch (e) { clearInterval(poll); }
                                    }, 60);
                                } catch (e) {}
                            } catch (e) { /* ignore */ }
                        }
                    }]
            });
        } else {
            // Fallback to simple prompt if panel function not available
            let options = [];
            if (playerResources > 0) {
                options.push({label: `Sell Resources (${tradeValue} credits)`, action: () => this.sellResources()});
            }
            if (canRepair) {
                options.push({label: `Repair Ship (${repairCost} credits)`, action: () => this.repairShip()});
            }
            options.push({label: 'Leave Station', action: () => this.undock()});
            
            G.showPrompt(`${title}\nResources: ${playerResources}\nCredits: ${playerCredits}\nRate: ${this.resourcesPerCredit.toFixed(1)} resources/credit\nSell Value: ${tradeValue}`, options);
        }
    }
    
    sellResources() {
        let playerResources = U.playerShip.civilization ? U.playerShip.civilization.resources : 0;
        let tradeValue = Math.floor(playerResources * this.tradeRate);
        
        if (playerResources > 0) {
            // Add credits to player
            U.playerShip.credits = (U.playerShip.credits || 0) + tradeValue;
            
            // Remove resources from player
            if (U.playerShip.civilization) {
                U.playerShip.civilization.resources = 0;
            }
        }
        
        // Refresh the trading interface
        this.showTradingInterface();
    }
    
    repairShip() {
        let repairCost = 20;
        let playerCredits = U.playerShip.credits || 0;
        
        if (playerCredits >= repairCost && (U.playerShip.health < 1 || U.playerShip.shield < 1)) {
            // Deduct credits
            U.playerShip.credits -= repairCost;
            
            // Restore health and shields to full
            U.playerShip.health = 1;
            U.playerShip.shield = 1;
        }
        
        // Refresh the trading interface
        this.showTradingInterface();
    }
    
    undock() {
        // Remove trading panel
        let tradingPanel = document.getElementById('trading-panel');
        if (tradingPanel) {
            tradingPanel.remove();
        }
        
        // Disconnect ship from station
        if (U.playerShip.dockedStation === this) {
            U.playerShip.dockedStation = null;
            U.playerShip.isDocked = 0;
            U.playerShip.dockOffset = null;
            U.playerShip.inTradingInterface = 0;
        }
        
        // Clear any remaining prompts
        G.showPrompt();
    }

    explode(source) {
        for (let i = 0; i < 50; i++) {
            let angle = random() * TWO_PI;
            let distance = rnd(30, 50);

            particle(pick(['#ff0', '#f80', '#f00']), [
                ['alpha', 1, 0, 1],
                ['size', rnd(2, 4), rnd(5, 10), 1],
                ['x', this.x, this.x + cos(angle) * distance, 1],
                ['y', this.y, this.y + sin(angle) * distance, 1]
            ]);
        }

        U.remove(U.orbitalStations, this);

        if (source == U.playerShip) {
            this.civilization.updateRelationship(-0.2);
        }

        U.dropResources(this.x, this.y, 15);
    }

    nameWithRelationship() {
        return 'Orbital Station (' + this.civilization.relationshipLabel() + ')';
    }

}

class Item {

    constructor(x, y) {
        this.scaleRandom = random();
        this.timeLeft = 15;

        interp(this, 'x', x, x + rnd(-50, 50), 0.3);
        interp(this, 'y', y, y + rnd(-50, 50), 0.3);
    }

    cycle(e) {
        if ((this.timeLeft -= e) <= 0) {
            U.remove(U.items, this);
        }

        if (U.playerShip.health <= 0) {
            return;
        }

        let distance = dist(this, U.playerShip);
        if (distance < 80) {
            let angle = angleBetween(this, U.playerShip);
            this.x += cos(angle) * min(distance, 200 * e);
            this.y += sin(angle) * min(distance, 200 * e);
        }

        if (distance < 10) {
            U.remove(U.items, this);
            this.pickUp(U.playerShip);
        }
    }

    render() {
        if (!V.isVisible(this) || this.timeLeft < 3 && (this.timeLeft % 0.25) < 0.125) {
            return;
        }

        translate(this.x, this.y);
        scale(sin(this.scaleRandom + TWO_PI * G.clock), 1); // Give the item a nice flip animation

        this.renderGraphic();
    }

    // For reference only
    // pickUp(ship) {

    // }

    // For reference only
    // renderGraphic() {

    // }

}

class ResourceItem extends Item {

    renderGraphic() {
        scale(0.3, 0.3);

        fs('#fff');
        renderResourcesIcon();
    }

    pickUp(ship) {
        ship.civilization.resources = min(200, ship.civilization.resources + 1);
        G.eventHub.emit(3, this);

        G.resourceAnimation();

        pickupSound();
    }

}

class CargoItem extends Item {

    constructor(x, y, cargoName = 'Cryogenic Embryos', units = 1) {
        super(x, y);
        this.cargoName = cargoName;
        this.units = units || 1;
        // Make cargo easier to spot and persist until collected (don't auto-expire)
        this.timeLeft = Infinity;

        // Emit a gold flash particle so player notices the drop
        try {
            particle('#ffd700', [
                ['alpha', 1, 0, 0.2],
                ['size', 10, 40, 0.2],
                ['x', this.x, this.x, 0],
                ['y', this.y, this.y, 0]
            ]);
        } catch (e) {
            // ignore if particle not available
        }
    }

    renderGraphic() {
        // Golden box: draw a larger gold cube/box with glow
        scale(0.7, 0.7);

        // Glow
        try { R.shadowColor = 'rgba(255,215,0,0.8)'; R.shadowBlur = 20; } catch (e) {}

        // box base
        fs('#d4af37'); // gold
        beginPath();
        moveTo(-18, -12);
        lineTo(18, -12);
        lineTo(18, 12);
        lineTo(-18, 12);
        closePath();
        fill();

        // highlight
        fs('#ffe680');
        beginPath();
        moveTo(-18, -12);
        lineTo(18, -12);
        lineTo(12, -7);
        lineTo(-12, -7);
        closePath();
        fill();

        // stripe
        fs('#b8860b');
        beginPath();
        moveTo(-6, -12);
        lineTo(6, -12);
        lineTo(6, 12);
        lineTo(-6, 12);
        closePath();
        fill();

        try { R.shadowBlur = 0; } catch (e) {}
    }

    pickUp(ship) {
    // Award a random credit bonus between 0 and 99
    let creditBonus = Math.floor(Math.random() * 100);
    ship.credits = (ship.credits || 0) + creditBonus;

        // Ensure ship cargo map exists
        ship.cargo = ship.cargo || {};

        // Determine per-unit storage for this cargo
        let perUnit = 1;
        try {
            if (typeof CARGO_DATA !== 'undefined' && Array.isArray(CARGO_DATA)) {
                let def = CARGO_DATA.find(d => d.cargo === this.cargoName || String(d.id) === String(this.cargoName));
                if (def && def.storage_units) perUnit = def.storage_units;
            }
        } catch (e) {}

        // Compute remaining capacity in units (not cargo types)
        let CAP = 200;
        let used = 0;
        try { Object.keys(ship.cargo).forEach(k => { let d = (typeof CARGO_DATA !== 'undefined' && Array.isArray(CARGO_DATA)) ? CARGO_DATA.find(dd => dd.cargo === k) : null; let pu = d && d.storage_units ? d.storage_units : 1; used += (ship.cargo[k] || 0) * pu; }); } catch (e) {}
        let remainingUnits = Math.max(0, CAP - used);

        // How many of this cargo can we accept?
        let maxAccept = Math.floor(remainingUnits / perUnit);
        let toAccept = Math.max(0, Math.min(this.units || 0, maxAccept));

        if (toAccept > 0) {
            ship.cargo[this.cargoName] = (ship.cargo[this.cargoName] || 0) + toAccept;
        }

    // Show the total units that were collected from the wreck in the main prompt
    let collectedUnits = this.units || 0;
    let msg = `Picked up ${collectedUnits} ${this.cargoName} (+${creditBonus} credits)`;
        if (toAccept > 0 && toAccept < this.units) {
            msg += ` — stored ${toAccept}/${this.units} units (ship full)`;
        } else if (toAccept === 0) {
            msg += ' — no cargo space available';
        }

        // Show pickup details as a prompt (typed bottom-of-screen) rather than a banner
        try {
            if (typeof G !== 'undefined' && G.showPrompt) {
                G.showPrompt(nomangle(msg));
            } else {
                G.showMessage(nomangle(msg));
            }
        } catch (e) {
            try { G.showMessage(nomangle(msg)); } catch (e2) { /* ignore */ }
        }
        pickupSound();
    }

}

class Laser {

    constructor(owner, x, y, angle) {
        this.owner = owner;
        this.x = x;
        this.y = y;
        this.angle = angle;
        // this.speed = 800;
        // this.radius = 10;
        // this.heat = 0.05;
        this.guideRadius = 0;
        this.age = 0;

        shootSound();
    }

    cycle(e) {
        this.x += cos(this.angle) * this.speed * e;
        this.y += sin(this.angle) * this.speed * e;

        if (!V.isVisible(this, 500) || (this.age += e) >= 2) {
            U.remove(U.projectiles, this);
        }

        // Collisions
        U.forEachTarget(target => {
            if (target === this.owner) {
                return;
            }

            if (dist(target, this) < target.radius + this.radius && !U.playerShip.isDocked) {
                U.remove(U.projectiles, this);
                target.damage(this, this.damage);

                hitSound();
            }

            if (dist(target, this) < this.guideRadius) {
                let angleToTarget = angleBetween(this, target);
                let angleDiff = normalize(angleToTarget - this.angle);
                if (abs(angleDiff) < PI / 4) {
                    let appliedDiff = limit(-e * PI / 2, angleDiff, e * PI / 2);
                    this.angle += appliedDiff;
                }
            }
        });
    }

    // For reference only
    // render() {
    //
    // }

}

class SimpleLaser extends Laser {

    constructor(owner, x, y, angle) {
        super(owner, x, y, angle);
        this.speed = 400;
        this.radius = 4;
        this.damage = 0.1;
        this.heat = 0.05;
    }

    cycle(e) {
        super.cycle(e);

        let d = 0.3;
        particle('cyan', [
            ['alpha', 1, 0, d],
            ['size', 4, rnd(4, 6), d],
            ['x', this.x, this.x + rnd(-3, 3), d],
            ['y', this.y, this.y + rnd(-3, 3), d]
        ]);
    }

    render() {
        translate(this.x, this.y);
        rotate(this.angle);

        fs('cyan');
        fr(0, -2, 8, 4);
    }

}

class SuperLaser extends Laser {

    constructor(owner, x, y, angle) {
        super(owner, x, y, angle);
        this.speed = 800;
        this.clock = 0;
        this.radius = 15;
        this.damage = 0.5;
        this.heat = 0.5;
    }

    cycle(e) {
        super.cycle(e);

        let s = sin((this.clock += e) * TWO_PI * 4) * 0;

        let d = 0.5;
        particle('red', [
            ['alpha', 1, 0, d],
            ['size', 16, rnd(16, 32), d],
            ['x', this.x + cos(this.angle + PI / 2) * s * 10, this.x + cos(this.angle + PI / 2) * s * 10 + rnd(-16, 16), d],
            ['y', this.y + sin(this.angle + PI / 2) * s * 10, this.y + sin(this.angle + PI / 2) * s * 10 + rnd(-16, 16), d]
        ]);
    }

    render() {
        translate(this.x, this.y);
        rotate(this.angle);

        fs('red');
        fr(-5, -5, 10, 10);
    }

}

onresize = () => {
    var mw = innerWidth,
        mh = innerHeight,

        ar = mw / mh, // available ratio
        br = 1000 / CANVAS_HEIGHT, // base ratio
        w,
        h,
        s = document.querySelector('#cc').style;

    if (ar <= br) {
        w = mw;
        h = w / br;
    } else {
        h = mh;
        w = h * br;
    }

    s.width = w + 'px';
    s.height = h + 'px';
};

linear = (t, b, c, d) => {
    return (t / d) * c + b;
};

interp = (o, p, a, b, d, l, f, e) => {
    var i = {
        o: o, // object
        p: p, // property
        a: a, // from
        b: b, // to
        d: d, // duration
        l: l || 0, // delay
        f: f || linear, // easing function
        e: e || (() => 0), // end callback
        t: 0,
        cycle: e => {
            if (i.l > 0) {
                i.l -= e;
                i.o[i.p] = i.a;
            } else {
                i.t = min(i.d, i.t + e);
                i.o[i.p] = i.f(i.t, i.a, i.b - i.a, i.d);
                if (i.t == i.d) {
                    i.e();

                    let index = INTERPOLATIONS.indexOf(i);
                    if (index >= 0) INTERPOLATIONS.splice(index, 1);
                }
            }
        }
    };
    INTERPOLATIONS.push(i);
};

INTERPOLATIONS = [];

let consonants = 'BCDFGHJKLMNPQRSTVWXZ'.split('');
let vowels = 'AEIOUY'.split('');

randomSyllable = rng => rng.pick(consonants) + rng.pick(vowels) + rng.pick(consonants.concat(vowels));

randomName = rng => randomSyllable(rng) + randomSyllable(rng) + ' ' + rng.pick(['III', 'IV', 'V', 'VI', 'VII', 'IX', 'X']);

addZeroes = text => {
    text = text + '';
    while (text.length < 2) {
        text = '0' + text;
    }
    return text;
};

formatTime = t => addZeroes(~~(t / 60)) + ':' + addZeroes(~~t % 60);

pointsAround = (center, radiuses) => {
    let pts = [];

    let circles = [];
    radiuses.forEach(radius => {
        let circle = [];
        circles.push(circle);

        for (let i = 0 ; i < 6 ; i++) {
            let angle = TWO_PI * (i / 6);
            let pt = {
                'x': cos(angle) * radius + center.x,
                'y': sin(angle) * radius + center.y,
                'neighbors': []
            };
            pts.push(pt);

            circle.push(pt);
        }
    });

    circles.forEach((circle, circleIndex) => {
        circle.forEach((pt, ptIndex) => {
            // Link within the same circle
            let circleNeighbor = circle[(ptIndex + 1) % circle.length];
            pt.neighbors.push(circleNeighbor);
            circleNeighbor.neighbors.push(pt);

            // Link between circles
            let radiusNeighbor = circles[(circleIndex + 1) % circles.length][ptIndex];
            pt.neighbors.push(radiusNeighbor);
            radiusNeighbor.neighbors.push(pt);
        });
    });

    return pts;
}

createNumberGenerator = seed => {
    let ints = new Uint32Array([
        imul(seed, 0x85ebca6b),
        imul(seed, 0xc2b2ae35),
    ]);

    let generateFloat = () => {
        let s0 = ints[0];
        let s1 = ints[1] ^ s0;
        ints[0] = (s0 << 26 | s0 >> 8) ^ s1 ^ s1 << 9;
        ints[1] = s1 << 13 | s1 >> 19;
        return (imul(s0, 0x9e3779bb) >>> 0) / 0xffffffff;
    };

    return {
        'pick': a => a[~~(generateFloat() * a.length)],
        'between': (a, b) => generateFloat() * (b - a) + a,
        'floating': generateFloat
    };
};

once = f => {
    let res
    return () => {
        res = res || f();
        return res;
    };
};

/**
* SfxrParams
*
* Copyright 2010 Thomas Vian
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* @author Thomas Vian
*/
/** @constructor */
function SfxrParams() {
    //--------------------------------------------------------------------------
    //
    //  Settings String Methods
    //
    //--------------------------------------------------------------------------

    /**
    * Parses a settings array into the parameters
    * @param array Array of the settings values, where elements 0 - 23 are
    *                a: waveType
    *                b: attackTime
    *                c: sustainTime
    *                d: sustainPunch
    *                e: decayTime
    *                f: startFrequency
    *                g: minFrequency
    *                h: slide
    *                i: deltaSlide
    *                j: vibratoDepth
    *                k: vibratoSpeed
    *                l: changeAmount
    *                m: changeSpeed
    *                n: squareDuty
    *                o: dutySweep
    *                p: repeatSpeed
    *                q: phaserOffset
    *                r: phaserSweep
    *                s: lpFilterCutoff
    *                t: lpFilterCutoffSweep
    *                u: lpFilterResonance
    *                v: hpFilterCutoff
    *                w: hpFilterCutoffSweep
    *                x: masterVolume
    * @return If the string successfully parsed
    */
    this.setSettings = function(values){
        for(var i = 0 ; i < 24 ; i++){
            this[String.fromCharCode(97 + i)] = values[i] || 0;
        }

        // I moved this here from the reset(1) function
        if (this.c < 0.01) {
            this.c = 0.01;
        }

        var totalTime = this.b + this.c + this.e;
        if (totalTime < 0.18) {
            var multiplier = 0.18 / totalTime;
            this.b *= multiplier;
            this.c *= multiplier;
            this.e *= multiplier;
        }
    };
}

/**
* SfxrSynth
*
* Copyright 2010 Thomas Vian
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* @author Thomas Vian
*/
/** @constructor */
function SfxrSynth() {
    // All variables are kept alive through function closures

    //--------------------------------------------------------------------------
    //
    //  Sound Parameters
    //
    //--------------------------------------------------------------------------

    this._params = new SfxrParams();  // Params instance

    //--------------------------------------------------------------------------
    //
    //  Synth Variables
    //
    //--------------------------------------------------------------------------

    var _envelopeLength0, // Length of the attack stage
        _envelopeLength1, // Length of the sustain stage
        _envelopeLength2, // Length of the decay stage

        _period,          // Period of the wave
        _maxPeriod,       // Maximum period before sound stops (from minFrequency)

        _slide,           // Note slide
        _deltaSlide,      // Change in slide

        _changeAmount,    // Amount to change the note by
        _changeTime,      // Counter for the note change
        _changeLimit,     // Once the time reaches this limit, the note changes

        _squareDuty,      // Offset of center switching point in the square wave
        _dutySweep;       // Amount to change the duty by

    //--------------------------------------------------------------------------
    //
    //  Synth Methods
    //
    //--------------------------------------------------------------------------

    /**
    * Resets the runing variables from the params
    * Used once at the start (total reset) and for the repeat effect (partial reset)
    */
    this.resetManglable = function() {
        // Shorter reference
        var p = this._params;

        _period       = 100 / (p.f * p.f + 0.001);
        _maxPeriod    = 100 / (p.g   * p.g   + 0.001);

        _slide        = 1 - p.h * p.h * p.h * 0.01;
        _deltaSlide   = -p.i * p.i * p.i * 0.000001;

        if(!p.a){
            _squareDuty = 0.5 - p.n / 2;
            _dutySweep  = -p.o * 0.00005;
        }

        _changeAmount = 1 + p.l * p.l * (p.l > 0 ? -0.9 : 10);
        _changeTime   = 0;
        _changeLimit  = p.m == 1 ? 0 : (1 - p.m) * (1 - p.m) * 20000 + 32;
    };

    // I split the reset() function into two functions for better readability
    this.totalReset = function() {
        this.resetManglable();

        // Shorter reference
        var p = this._params;

        // Calculating the length is all that remained here, everything else moved somewhere
        _envelopeLength0 = p.b  * p.b  * 100000;
        _envelopeLength1 = p.c * p.c * 100000;
        _envelopeLength2 = p.e   * p.e   * 100000 + 12;
        // Full length of the volume envelop (and therefore sound)
        // Make sure the length can be divided by 3 so we will not need the padding "==" after base64 encode
        return ((_envelopeLength0 + _envelopeLength1 + _envelopeLength2) / 3 | 0) * 3;
    };

    /**
    * Writes the wave to the supplied buffer ByteArray
    * @param buffer A ByteArray to write the wave to
    * @return If the wave is finished
    */
    this.synthWave = function(buffer, length) {
        // Shorter reference
        var p = this._params;

        // If the filters are active
        var _filters = p.s != 1 || p.v,
            // Cutoff multiplier which adjusts the amount the wave position can move
            _hpFilterCutoff = p.v * p.v * 0.1,

            // Speed of the high-pass cutoff multiplier
            _hpFilterDeltaCutoff = 1 + p.w * 0.0003,

            // Cutoff multiplier which adjusts the amount the wave position can move
            _lpFilterCutoff = p.s * p.s * p.s * 0.1,

            // Speed of the low-pass cutoff multiplier
            _lpFilterDeltaCutoff = 1 + p.t * 0.0001,

            // If the low pass filter is active
            _lpFilterOn = p.s != 1,

            // masterVolume * masterVolume (for quick calculations)
            _masterVolume = p.x * p.x,

            // Minimum frequency before stopping
            _minFreqency = p.g,

            // If the phaser is active
            _phaser = p.q || p.r,

            // Change in phase offset
            _phaserDeltaOffset = p.r * p.r * p.r * 0.2,

            // Phase offset for phaser effect
            _phaserOffset = p.q * p.q * (p.q < 0 ? -1020 : 1020),

            // Once the time reaches this limit, some of the    iables are reset
            _repeatLimit = p.p ? ((1 - p.p) * (1 - p.p) * 20000 | 0) + 32 : 0,

            // The punch factor (louder at begining of sustain)
            _sustainPunch = p.d,

            // Amount to change the period of the wave by at the peak of the vibrato wave
            _vibratoAmplitude = p.j / 2,

            // Speed at which the vibrato phase moves
            _vibratoSpeed = p.k * p.k * 0.01,

            // The type of wave to generate
            _waveType = p.a;

        var _envelopeLength      = _envelopeLength0,     // Length of the current envelope stage
            _envelopeOverLength0 = 1 / _envelopeLength0, // (for quick calculations)
            _envelopeOverLength1 = 1 / _envelopeLength1, // (for quick calculations)
            _envelopeOverLength2 = 1 / _envelopeLength2; // (for quick calculations)

        // Damping muliplier which restricts how fast the wave position can move
        var _lpFilterDamping = 5 / (1 + p.u * p.u * 20) * (0.01 + _lpFilterCutoff);
        if (_lpFilterDamping > 0.8) {
            _lpFilterDamping = 0.8;
        }
        _lpFilterDamping = 1 - _lpFilterDamping;

        var _finished = 0,     // If the sound has finished
            _envelopeStage    = 0, // Current stage of the envelope (attack, sustain, decay, end)
            _envelopeTime     = 0, // Current time through current enelope stage
            _envelopeVolume   = 0, // Current volume of the envelope
            _hpFilterPos      = 0, // Adjusted wave position after high-pass filter
            _lpFilterDeltaPos = 0, // Change in low-pass wave position, as allowed by the cutoff and damping
            _lpFilterOldPos,       // Previous low-pass wave position
            _lpFilterPos      = 0, // Adjusted wave position after low-pass filter
            _periodTemp,           // Period modified by vibrato
            _phase            = 0, // Phase through the wave
            _phaserInt,            // Integer phaser offset, for bit maths
            _phaserPos        = 0, // Position through the phaser buffer
            _pos,                  // Phase expresed as a Number from 0-1, used for fast sin approx
            _repeatTime       = 0, // Counter for the repeats
            _sample,               // Sub-sample calculated 8 times per actual sample, averaged out to get the super sample
            _superSample,          // Actual sample writen to the wave
            _vibratoPhase     = 0; // Phase through the vibrato sine wave

        // Buffer of wave values used to create the out of phase second wave
        var _phaserBuffer = new Array(1024),

            // Buffer of random values used to generate noise
            _noiseBuffer  = new Array(32);

        for (var i = _phaserBuffer.length; i--; ) {
            _phaserBuffer[i] = 0;
        }
        for (i = _noiseBuffer.length; i--; ) {
            _noiseBuffer[i] = rnd(-1, 1);
        }

        for (i = 0; i < length; i++) {
            if (_finished) {
                return i;
            }

            // Repeats every _repeatLimit times, partially resetting the sound parameters
            if (_repeatLimit) {
                if (++_repeatTime >= _repeatLimit) {
                    _repeatTime = 0;
                    this.resetManglable();
                }
            }

            // If _changeLimit is reached, shifts the pitch
            if (_changeLimit) {
                if (++_changeTime >= _changeLimit) {
                    _changeLimit = 0;
                    _period *= _changeAmount;
                }
            }

            // Acccelerate and apply slide
            _slide += _deltaSlide;
            _period *= _slide;

            // Checks for frequency getting too low, and stops the sound if a minFrequency was set
            if (_period > _maxPeriod) {
                _period = _maxPeriod;
                if (_minFreqency > 0) {
                    _finished = 1;
                }
            }

            _periodTemp = _period;

            // Applies the vibrato effect
            if (_vibratoAmplitude > 0) {
                _vibratoPhase += _vibratoSpeed;
                _periodTemp *= 1 + sin(_vibratoPhase) * _vibratoAmplitude;
            }

            _periodTemp |= 0;
            if (_periodTemp < 8) {
                _periodTemp = 8;
            }

            // Sweeps the square duty
            if (!_waveType) {
                _squareDuty += _dutySweep;
                if (_squareDuty < 0) {
                    _squareDuty = 0;
                } else if (_squareDuty > 0.5) {
                    _squareDuty = 0.5;
                }
            }

            // Moves through the different stages of the volume envelope
            if (++_envelopeTime > _envelopeLength) {
                _envelopeTime = 0;

                switch (++_envelopeStage)  {
                    case 1:
                        _envelopeLength = _envelopeLength1;
                        break;
                    case 2:
                        _envelopeLength = _envelopeLength2;
                }
            }

            // Sets the volume based on the position in the envelope
            switch (_envelopeStage) {
                case 0:
                    _envelopeVolume = _envelopeTime * _envelopeOverLength0;
                    break;
                case 1:
                    _envelopeVolume = 1 + (1 - _envelopeTime * _envelopeOverLength1) * 2 * _sustainPunch;
                    break;
                case 2:
                    _envelopeVolume = 1 - _envelopeTime * _envelopeOverLength2;
                    break;
                case 3:
                    _envelopeVolume = 0;
                    _finished = 1;
            }

            // Moves the phaser offset
            if (_phaser) {
                _phaserOffset += _phaserDeltaOffset;
                _phaserInt = _phaserOffset | 0;
                if (_phaserInt < 0) {
                    _phaserInt = -_phaserInt;
                } else if (_phaserInt > 1023) {
                    _phaserInt = 1023;
                }
            }

            // Moves the high-pass filter cutoff
            if (_filters && _hpFilterDeltaCutoff) {
                _hpFilterCutoff *= _hpFilterDeltaCutoff;
                if (_hpFilterCutoff < 0.00001) {
                    _hpFilterCutoff = 0.00001;
                } else if (_hpFilterCutoff > 0.1) {
                    _hpFilterCutoff = 0.1;
                }
            }

            _superSample = 0;
            for (var j = 8; j--; ) {
                // Cycles through the period
                _phase++;
                if (_phase >= _periodTemp) {
                    _phase %= _periodTemp;

                    // Generates new random noise for this period
                    if (_waveType == 3) {
                        for (var n = _noiseBuffer.length; n--; ) {
                            _noiseBuffer[n] = rnd(-1, 1);
                        }
                    }
                }

                // Gets the sample from the oscillator
                switch (_waveType) {
                    case 0: // Square wave
                        _sample = ((_phase / _periodTemp) < _squareDuty) ? 0.5 : -0.5;
                        break;
                    case 1: // Saw wave
                        _sample = 1 - _phase / _periodTemp * 2;
                        break;
                    case 2: // Sine wave (fast and accurate approx)
                        _pos = _phase / _periodTemp;
                        _pos = (_pos > 0.5 ? _pos - 1 : _pos) * 6.28318531;
                        _sample = 1.27323954 * _pos + 0.405284735 * _pos * _pos * (_pos < 0 ? 1 : -1);
                        _sample = 0.225 * ((_sample < 0 ? -1 : 1) * _sample * _sample  - _sample) + _sample;
                        break;
                    case 3: // Noise
                        _sample = _noiseBuffer[abs(_phase * 32 / _periodTemp | 0)];
                }

                // Applies the low and high pass filters
                if (_filters) {
                    _lpFilterOldPos = _lpFilterPos;
                    _lpFilterCutoff *= _lpFilterDeltaCutoff;
                    if (_lpFilterCutoff < 0) {
                        _lpFilterCutoff = 0;
                    } else if (_lpFilterCutoff > 0.1) {
                        _lpFilterCutoff = 0.1;
                    }

                    if (_lpFilterOn) {
                        _lpFilterDeltaPos += (_sample - _lpFilterPos) * _lpFilterCutoff;
                        _lpFilterDeltaPos *= _lpFilterDamping;
                    } else {
                        _lpFilterPos = _sample;
                        _lpFilterDeltaPos = 0;
                    }

                    _lpFilterPos += _lpFilterDeltaPos;

                    _hpFilterPos += _lpFilterPos - _lpFilterOldPos;
                    _hpFilterPos *= 1 - _hpFilterCutoff;
                    _sample = _hpFilterPos;
                }

                // Applies the phaser effect
                if (_phaser) {
                    _phaserBuffer[_phaserPos % 1024] = _sample;
                    _sample += _phaserBuffer[(_phaserPos - _phaserInt + 1024) % 1024];
                    _phaserPos++;
                }

                _superSample += _sample;
            }

            // Averages out the super samples and applies volumes
            _superSample *= 0.125 * _envelopeVolume * _masterVolume;

            // Clipping if too loud
            buffer[i] = _superSample >= 1 ? 32767 : _superSample <= -1 ? -32768 : _superSample * 32767 | 0;
        }

        return length;
    };
}

// Adapted from http://codebase.es/riffwave/
var synth = new SfxrSynth();

// Export for the Closure Compiler
var jsfxr = function(settings) {
    // Initialize SfxrParams
    synth._params.setSettings(settings);

    // Synthesize Wave
    var envelopeFullLength = synth.totalReset();
    var data = new Uint8Array(((envelopeFullLength + 1) / 2 | 0) * 4 + 44);
    var used = synth.synthWave(new Uint16Array(data.buffer, 44), envelopeFullLength) * 2;
    var dv = new Uint32Array(data.buffer, 0, 44);

    // Initialize header
    dv[0] = 0x46464952; // "RIFF"
    dv[1] = used + 36;  // put total size here
    dv[2] = 0x45564157; // "WAVE"
    dv[3] = 0x20746D66; // "fmt "
    dv[4] = 0x00000010; // size of the following
    dv[5] = 0x00010001; // Mono: 1 channel, PCM format
    dv[6] = 0x0000AC44; // 44,100 samples per second
    dv[7] = 0x00015888; // byte rate: two bytes per sample
    dv[8] = 0x00100002; // 16 bits per sample, aligned on every two bytes
    dv[9] = 0x61746164; // "data"
    dv[10] = used;      // put number of samples here

    // Base64 encoding written by me, @maettig
    used += 44;
    var i = 0,
        base64Characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        output = 'data:audio/wav;base64,';
    for (; i < used; i += 3){
        var a = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
        output += base64Characters[a >> 18] + base64Characters[a >> 12 & 63] + base64Characters[a >> 6 & 63] + base64Characters[a & 63];
    }

    var audio = new Audio();
    audio.src = output;
    return audio;
};

soundPool = (settings, poolSize = 1) => {
    let index = 0;
    let sounds = once(() => [...Array(poolSize)].map(() => jsfxr(settings)));

    return () => {
        let sound = sounds()[index++ % sounds().length];
        sound.play();
        return sound;
    };
};

let explosionSound = soundPool([3,,0.3346,0.2953,0.4941,0.1205,,-0.2565,,,,,,,,,-0.1093,-0.2344,1,,,,,0.5]);

let shootSound = soundPool([0,,0.1584,0.1384,0.2216,0.63,,-0.2653,,,,,,0.1485,,,,,1,,,0.1888,,0.5], 10),
    promptSound = soundPool([1,0.12,0.1,0.0079,0.32,0.83,0.0017,,0.04,0.34,0.96,0.0056,,,0.8422,0.0048,,-0.0327,1,,,,,0.37]),
    selectSound = soundPool([0,,0.1696,,0.0103,0.2617,,,,,,,,0.1416,,,,,1,,,0.1,,0.5]),
    pickupSound = soundPool([0,,0.0323,0.3656,0.1925,0.4276,,,,,,,,,,,,,1,,,,,0.5], 10),
    creditPickupSound = soundPool([0,0.12,0.08,0.21,0.34,0.72,0.03,,0.12,0.2,0.4,0.01,,,,,0.1,,0.9,,0.5], 6),
    hitSound = soundPool([3,,0.0825,,0.2264,0.3697,,-0.5926,,,,,,,,,,,1,,,0.0684,,0.5], 10),
    thrustSound = soundPool([3,,1,,,0.14,,,,,,,,,,1,,,1,,,0.0684,,0.2], 1),
    introSound = soundPool([2,1,0.01,0.0079,1,0.23,0.0017,0.0194,0.0078,0.81,0.41,0.0056,,,0.8422,0.0048,,-0.0327,1,,,,,0.45]),
    findSytemSound = soundPool([2,0.72,0.01,0.0079,1,0.6,0.0017,0.0194,0.0078,0.57,0.71,0.0056,,,0.8422,0.0048,,-0.0327,1,,,,,0.45]),
    warningSound = soundPool([1,0.03,0.42,0.0079,0.32,0.14,0.0017,,0.04,,,0.0056,,,0.8422,0.0048,,-0.0327,1,,,,,0.37]);

class EventHub {

    constructor() {
        this.listeners = {};
    }

    emit(event, eventData) {
        (this.listeners[event] || []).forEach(listener => listener(eventData));
    }

    listen(event, listener) {
        this.listeners[event] = this.listeners[event] || [];
        this.listeners[event].push(listener);
    }

    ignore(event, listener) {
        let index = (this.listeners[event] || []).indexOf(listener);
        if (index >= 0) {
            this.listeners[event].splice(index, 1);
        }
    }

}

w.down = {};
onkeydown = e => {
    w.down[e.keyCode] = 1;
};
onkeyup = e => {
    w.down[e.keyCode] = 0;
    let character = String.fromCharCode(e.keyCode).toLowerCase();
    if (isNaN(character)) {
        G.selectPromptOption(character);
    }

    // Docking / trading shortcut: press 'D' to dock to a nearby orbital station or open planetary trade when in range
    try {
    if (character === 'd' && typeof U !== 'undefined' && U && U.playerShip) {
            // First try orbital stations (within 120 units)
            if (U.orbitalStations) {
                let nearbyStation = U.orbitalStations.find(station => dist(station, U.playerShip) < 120);
                if (nearbyStation) {
                    nearbyStation.dock();
                    return;
                }
            }

            // Next, check planets (within planet.reachRadius)
            if (U.bodies) {
                let nearbyPlanet = U.bodies.find(body => body instanceof Planet && dist(body, U.playerShip) < body.reachRadius && body.civilization && body.civilization.relationshipType && body.civilization.relationshipType() === '#0f0');
                if (nearbyPlanet) {
                    if (window.createPlanetaryTradePanel) {
                        window.createPlanetaryTradePanel(nearbyPlanet, U.playerShip);
                    } else {
                        G.showPrompt((nearbyPlanet.name || 'Unknown') + '\nPlanetary trade unavailable');
                    }
                }
            }
        }

        // Allow Leave (L) and Escape to undock from planetary trade when docked to a planet
        try {
            if ((character === 'l' || e.keyCode === 27) && U.playerShip && U.playerShip.inTradingInterface && U.playerShip.dockedPlanet) {
                if (window.planetaryUndock) window.planetaryUndock();
            }
        } catch (err) {
            console.log('Undock attempt error:', err && err.message);
        }
        
        // Debug shortcut: SHIFT + Q grants 10000 credits while in a station/planet trading interface
        try {
            if (character === 'q' && e.shiftKey && U && U.playerShip && U.playerShip.inTradingInterface) {
                U.playerShip.credits = (U.playerShip.credits || 0) + 10000;
                try { G.showMessage && G.showMessage('Granted 10000 credits (debug)'); } catch (e2) { console.log('Granted 10000 credits (debug)'); }
            }
        } catch (err) { /* ignore debug key errors */ }
    } catch (err) {
        // Fail silently - keyboard shouldn't break the game
        console.log('Dock/Trade attempt error:', err && err.message);
    }
    try {
        // Access Incoming Communications with the 'A' key
        if (character === 'a' && typeof U !== 'undefined' && U && U.playerShip) {
            // Find a visible planet that currently has an offer (prefer closest)
            let visibleOffers = (U.bodies || []).filter(body => body instanceof Planet && body.hasOffer && V.isVisible(body, body.radius + 50));
            if (!visibleOffers.length) return;

            // pick the closest visible offered planet
            let chosen = visibleOffers.reduce((best, p) => {
                if (!best) return p;
                return dist(p, U.playerShip) < dist(best, U.playerShip) ? p : best;
            }, null);

            if (!chosen) return;

            // If planet is friendly and player is in reach, show a combined prompt with Dock (D) and Accept (A)
            let isFriendly = chosen.civilization && chosen.civilization.relationshipType && chosen.civilization.relationshipType() === '#0f0';
            let playerDistance = dist(chosen, U.playerShip);
            if (isFriendly && playerDistance < chosen.reachRadius) {
                let title = (chosen.name || 'Unknown');
                G.showPrompt(title + '\nPress [D] to dock\nPress [A] to accept incoming communication', [{
                    'label': 'Dock',
                    'action': () => {
                        if (window.createPlanetaryTradePanel) {
                            window.createPlanetaryTradePanel(chosen, U.playerShip);
                        } else {
                            G.showPrompt((chosen.name || 'Unknown') + '\nPlanetary trade unavailable');
                        }
                    }
                }, {
                    'label': 'Accept',
                    'action': () => { if (G && typeof G.promptMissionFromPlanet === 'function') G.promptMissionFromPlanet(chosen); }
                }, {
                    'label': 'Ignore',
                    'action': () => G.showPrompt()
                }]);
            } else {
                // Otherwise, directly start the mission prompt flow for that planet
                if (G && typeof G.promptMissionFromPlanet === 'function') G.promptMissionFromPlanet(chosen);
            }
        }
    } catch (err) {
        console.log('Access offers (A) error:', err && err.message);
    }
};

ontouchstart = e => ontouchmove(e, 1);

ontouchmove = ontouchend = (e, isTouchStart) => {
    e.preventDefault();

    let canvasRect = document.querySelector('canvas').getBoundingClientRect();

    w.down[32] = 0;
    w.down[37] = 0;
    w.down[38] = 0;
    w.down[39] = 0;

    for (let i = 0 ; i < e.touches.length ; i++) {
        let x = (e.touches[i].clientX - canvasRect.left) / canvasRect.width;
        let y = (e.touches[i].clientY - canvasRect.top) / canvasRect.height;
        if (y > 1 - 200 / CANVAS_HEIGHT) {
            if (x < 0.25) {
                w.down[37] = 1;
            } else if (x < 0.5) {
                w.down[39] = 1;
            } else if (x < 0.75) {
                w.down[32] = 1;
            } else {
                w.down[38] = 1;
            }
        } else if (isTouchStart && y > 1 - 400 / CANVAS_HEIGHT) {
            G.selectPromptOption(~~(x / (1 / (G.promptOptions || []).length)));
        }
    }

    isTouch = 1;

    G.start();
};

class Camera {

    constructor() {
        this.x = this.y = 0;
        this.shakeX = this.shakeY = 0;

        this.zoomScale = this.targetScale = 1;
        // this.targetScaleOverride = null; // for reference only
    }

    cycle(e) {
        let minDistance = 999;
        U.bodies.forEach(body => {
            minDistance = min(minDistance, dist(body, U.playerShip));
        });

        if (minDistance > 700) {
            this.targetScale = isTouch ? 0.7 : 0.5;
        } else if (minDistance < 500) {
            this.targetScale = 1;
        }

        let targetScale = this.targetScaleOverride || this.targetScale;

        this.zoomScale += limit(-0.5 * e, targetScale - this.zoomScale, 0.5 * e);

        this.visibleWidth = (1000 / this.zoomScale);
        this.visibleHeight = (CANVAS_HEIGHT / this.zoomScale);

        if ((this.shakeTime -= e) > 0) {
            this.shakeX = rnd(-10, 10);
            this.shakeY = rnd(-10, 10);
        }

        this.x = U.playerShip.x - this.visibleWidth / 2 + this.shakeX;
        this.y = U.playerShip.y - this.visibleHeight / 2 + this.shakeY;
    }

    isVisible(point, radius = 0) {
        return point.x + radius > this.x &&
            point.y + radius > this.y &&
            point.x - radius < this.x + this.visibleWidth &&
            point.y - radius < this.y + this.visibleHeight;
    }

    shake(duration) {
        this.shakeTime = max(this.shakeTime || 0, duration);
    }

}

class Game {

    constructor() {
        G = this;

        // Ensure any persisted world save is cleared before we construct the Universe
        // so a deliberate "New Game" (or fresh page load) doesn't restore planet
        // dispositions from a previous playthrough.
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.removeItem('ss_save_v1');
                try { console.debug('constructor: cleared persistent save before universe creation'); } catch (e) {}
            }
        } catch (e) { /* ignore */ }

        U = new Universe();

        V = new Camera();
        G.setupNewGame();
        G.lives = 3;

        G.clock = 0;
        // G.promptClock = 0; // for reference

        // G.message = null; // for reference
        // G.messageProgress = 0; // for reference

        // G.missionStep = null; // for reference

    G.titleStickString = stickString('SolarSpark');
    G.subtitleStickString = stickString('');
        G.instructionsStickString = stickString('press enter to send a ship');

        G.titleCharWidth = G.subtitleCharWidth = 50;
        G.titleCharHeight = G.subtitleCharHeight = 100;

        G.startedOnce = 0;
        G.startable = 1;

        G.resourceIconOffsetY = 0;
        G.resourceIconScale = 1;
        G.resourceIconAlpha = 1;
        G.healthIconScale = 1;

        G.healthGaugeColor = '#fff';
        G.lives = 3;
    }

    proceedToMissionStep(missionStep) {
        if (G.missionStep) {
            G.missionStep.detach();
        }

        G.missionStep = missionStep;
    // Mission timer: increase baseline so missions come roughly 1/10th as often
    G.nextMission = 200;

        G.showPrompt();

        if (!missionStep) {
            return;
        }

        missionStep.proceedListener = missionStep => G.proceedToMissionStep(missionStep);
        missionStep.attach();
    }

    renderGauge(x, y, ratio, color, renderIcon) {
        wrap(() => {
            translate(x, y);

            fs('rgba(128,128,128,0.5)');
            fr(0, -5, 200, 10);

            fs(color);
            fr(0, -5, -2, 10);
            fr(200, -5, 2, 10);

            fr(0, -5, 200 * limit(0, ratio, 1), 10);

            translate(-25, 0);
            renderIcon();
        });
    }

    healAnimation(callback) {
        interp(G, 'resourceIconOffsetY', 0, -30, 0.3, 0, 0, () => {
            G.resourceIconOffsetY = 0;
        });

        interp(G, 'healthIconScale', 1, 2, 0.3, 0.2, 0, () => {
            interp(G, 'healthIconScale', 2, 1, 0.3, 0, 0, () => {
                G.healthGaugeColor = '#fff';
        G.lives = 3;
            });
        });

        setTimeout(() => G.healthGaugeColor = '#0f0', 200);

        interp(G, 'resourceIconScale', 1, 0, 0.3, 0, 0, () => {
            G.resourceIconScale = 1;
            callback();
        });

        interp(G, 'resourceIconAlpha', 1, 0, 0.3, 0, 0, () => {
            interp(G, 'resourceIconAlpha', 0, 1, 0.3, 0.3);
        });
    }

    resourceAnimation() {
        interp(G, 'resourceIconScale', 1, 2, 0.3, 0, 0, () => {
            interp(G, 'resourceIconScale', 2, 1, 0.3);
        });

        // interp(G, 'resourceIconAlpha', 1, 0, 0.3, 0, 0, () => {
        //     interp(G, 'resourceIconAlpha', 0, 1, 0.1);
        // });
    }

    cycle(e) {
        G.clock += e;

        if (G.started) {
            if ((G.nextMission -= e) <= 0) {
                G.promptRandomMission();
            }

            U.cycle(e);
            G.eventHub.emit(1, e);
        }

        INTERPOLATIONS.slice().forEach(i => i.cycle(e));

        if (w.down[13] && !U.playerShip.inTradingInterface) {
            G.start();
        }

        // if (true) {
        //     G.renderedPlanets = 0;
        //     G.renderedOrbits = 0;
        //     G.renderedStars = 0;
        //     G.renderedAsteroids = 0;
        //     G.renderedShips = 0;
        //     G.renderedParticles = 0;
        // }

        U.render();

        // Render HUD
        wrap(() => {
            translate(V.shakeX, V.shakeY);

            fs('rgba(0,0,0,0.5)');
            R.strokeStyle = '#fff';
            fr(50, 30, 270, 125);
            strokeRect(50.5, 30.5, 270, 125);

            R.font = '10pt ' + monoFont;
            R.textAlign = 'center';
            fs('#fff');

            let allyMap = U.bodies.reduce((map, body) => {
                if (body.civilization) {
                    map[body.civilization.relationshipType()]++;
                    map.total++;
                }
                return map;
            }, {'total': 1, '#0f0': 0});

            fillText('Peace: ' + ~~(allyMap['#0f0'] * 100 / allyMap.total) + '%', 185, 140);

            G.renderGauge(100, 50, U.playerShip.health, (U.playerShip.health < 0.25 || G.clock - U.playerShip.lastDamage < 0.2) ? '#f00' : G.healthGaugeColor, () => {
                scale(0.5 * G.healthIconScale, 0.5 * G.healthIconScale);
                beginPath();
                moveTo(0, -15);
                lineTo(14, -10);
                lineTo(10, 10);
                lineTo(0, 18);
                lineTo(-10, 10);
                lineTo(-14, -10);
                fill();
            });

            wrap(() => {
                R.shadowColor = '#0f0';
                R.shadowBlur = 10;

                fs('cyan');
                fr(100, 45, 200 * limit(0, U.playerShip.shield, 1), 10);
            });

            // HUD debug: show absolute Shield and Hull current / max values as numbers
            try {
                R.font = '10pt ' + monoFont;
                R.textAlign = 'left';
                fs('#fff');

                // Shield: current (U.playerShip.shield) is 0..health (health normalized 0..1), but we want absolute points
                // Use the ship's current max shield/hull (which get updated by Mod Bay) for display
                let shieldBase = (typeof U.playerShip.maxShieldPoints === 'number') ? U.playerShip.maxShieldPoints : ((U.playerShip.baseStats && U.playerShip.baseStats.maxShieldPoints) ? U.playerShip.baseStats.maxShieldPoints : 100);
                let shieldCurrentPoints = Math.round((U.playerShip.shield || 0) * (shieldBase));
                let shieldText = 'Shield: ' + shieldCurrentPoints + ' / ' + (shieldBase);
                fillText(shieldText, 310, 60);

                // Hull: U.playerShip.health is 0..1, base hull points from baseStats or maxHullPoints
                let hullBase = (typeof U.playerShip.maxHullPoints === 'number') ? U.playerShip.maxHullPoints : ((U.playerShip.baseStats && U.playerShip.baseStats.maxHullPoints) ? U.playerShip.baseStats.maxHullPoints : 100);
                let hullCurrentPoints = Math.round((U.playerShip.health || 0) * hullBase);
                let hullText = 'Hull: ' + hullCurrentPoints + ' / ' + (hullBase);
                fillText(hullText, 310, 90);
            } catch (e) { /* non-fatal HUD overlay error */ }

            G.renderGauge(100, 80, U.playerShip.civilization.resources / 200, '#fff', () => {
                R.globalAlpha = G.resourceIconAlpha;

                translate(0, G.resourceIconOffsetY);
                scale(0.3 * G.resourceIconScale, 0.3 * G.resourceIconScale);
                renderResourcesIcon();
            });

            G.renderGauge(100, 110, U.playerShip.heat, U.playerShip.coolingDown ? '#f00' : '#fff', () => {
                fr(-5, -5, 3, 10);
                fr(-1, -5, 3, 10);
                fr(3, -5, 3, 10);
            });

            // Rendering targets
            let targets = [];

            let closestStars = U.stars.sort((a, b) => {
                return dist(a, U.playerShip) - dist(b, U.playerShip);
            }).slice(0, 3);

            let isInSystem = closestStars[0] && dist(closestStars[0], U.playerShip) < closestStars[0].reachRadius;

            if (isInSystem && !closestStars[0].systemDiscovered) {
                closestStars[0].systemDiscovered = 1;
                G.showMessage('system discovered - ' + closestStars[0].name);
            }

            if (G.missionStep) {
                targets = G.missionStep.targets || [];
                // (G.missionStep.targets || []).forEach(target => wrap(() => {
                //     U.transformToCamera();

                //     R.lineWidth = 4;
                //     R.strokeStyle = '#fff';
                //     R.globalAlpha = 0.1;

                //     setLineDash([20, 20]);
                //     beginPath();
                //     moveTo(U.playerShip.x, U.playerShip.y);
                //     lineTo(target.x, target.y);
                //     stroke();
                // }));
            } else if(!isInSystem) {
                targets = closestStars;
            }

            targets.forEach(target => {
                if (dist(target, U.playerShip) < (target.reachRadius || 0)) {
                    return;
                }

                let angle = angleBetween(U.playerShip, target);

                wrap(() => {
                    let distanceOnCircle = limit(0, (dist(target, U.playerShip) - target.reachRadius) / 4000, 1) * 200 + 50;

                    translate(1000 / 2 + cos(angle) * distanceOnCircle, CANVAS_HEIGHT / 2 + sin(angle) * distanceOnCircle);
                    rotate(angle);

                    // R.globalAlpha = 0.5;
                    fs(G.missionStep ? '#f80' : '#888');
                    beginPath();
                    moveTo(0, 0);
                    lineTo(-14, 10);
                    lineTo(-8, 0);
                    lineTo(-14, -10);
                    fill();
                });
            });

            // Prompt
            let promptText = G.promptText();
            if (promptText) {
                wrap(() => {
                    fs('rgba(0,0,0,0.5)');
                    R.font = '20pt ' + monoFont;

                    translate(0, CANVAS_HEIGHT - (isTouch ? 400 : 200));
                    fr(0, 0, 1000, 200);

                    let textWidth = measureText(promptText + '_').width;
                    let actualText = this.currentPromptText();

                    fs('#fff');
                    R.textAlign = 'left';
                    if (!G.selectedPromptOption) {
                        fillText(actualText, (1000 - textWidth) / 2, 50);
                    }

                    if (actualText.length >= promptText.length) {
                        R.textAlign = 'center';
                        R.textBaseline = 'middle';
                        R.font = '16pt ' + monoFont;

                        G.promptOptions.forEach((option, i) => {
                            fs('#fff');

                            if (G.selectedPromptOption) {
                                if (G.selectedPromptOption != option) {
                                    return;
                                }

                                R.globalAlpha = (sin(G.clock * TWO_PI * 4) + 1) / 2;
                            }

                            let promptText = '[' + option.label[0] + ']' + option.label.slice(1);
                            let x = (i + 1) * (1000 / (G.promptOptions.length + 1));

                            fr(x - 150 / 2, 100 - 30 / 2, 150, 30);

                            R.globalAlpha = 1;
                            fs('#000');
                            fillText(promptText, x, 100);
                        });
                    }
                });
            }

            let currentWarning = U.playerShip.currentWarning();
            if (currentWarning && currentWarning != G.currentWarning) {
                G.currentWarningEnd = G.clock + 3;
                G.currentWarning = currentWarning;

                warningSound();
            }

            if (!currentWarning) {
                G.currentWarning = 0;
            }

            if (G.currentWarning && G.clock < G.currentWarningEnd) {
                fs('rgba(255,0,0,0.5)');
                fr(0, 200, 1000, 125);

                R.font = '36pt ' + monoFont;
                R.textBaseline = 'middle';
                R.textAlign = 'center';
                fs('#fff');
                fillText('/!\\ WARNING /!\\', 1000 / 2, 250);

                R.font = '18pt ' + monoFont;
                fillText(G.currentWarning, 1000 / 2, 300);

                G.message = 0; // don't want to have a warning and a message at the same time
            }

            R.strokeStyle = '#fff';
            R.lineCap = 'round';

            // Message
            if (G.message && G.messageProgress) {
                wrap(() => {
                    R.lineWidth = 4;

                    let messageWidth = G.message.width * 20;
                    translate((1000 - messageWidth) / 2, (CANVAS_HEIGHT - 100) / 2 - 200);
                    renderStickString(G.message, 20, 30, G.messageProgress, 0.1, 1);
                });
            }

            // Game title
            wrap(() => {
                translate(0, G.titleYOffset);

                fs('#000');
                fr(0, 0, 1000, CANVAS_HEIGHT);

                R.lineWidth = 8;

                let everyonesY = (CANVAS_HEIGHT - G.titleCharHeight * 12 / 5) / 2;
                wrap(() => {
                    translate((1000 - G.titleStickString.width * G.titleCharWidth) / 2, everyonesY);
                    renderStickString(G.titleStickString, G.titleCharWidth, G.titleCharHeight, G.clock - 0.5, 0.1, 1);
                });

                wrap(() => {
                    R.lineWidth = G.subtitleCharThickness;
                    translate((1000 - G.subtitleStickString.width * G.subtitleCharWidth) / 2, everyonesY + G.titleCharHeight * 7 / 5);
                    renderStickString(G.subtitleStickString, G.subtitleCharWidth, G.subtitleCharHeight, G.clock - 0.5, 0.1 * (G.titleStickString.segments.length / G.subtitleStickString.segments.length), 1);
                });

                R.lineWidth = 4;

                let instructionCharWidth = 20;
                let instructionCharHeight = 30;
                wrap(() => {
                    if (G.clock % 1 > 0.5 && G.clock > 6 || G.titleYOffset) {
                        return;
                    }

                    translate((1000 - G.instructionsStickString.width * instructionCharWidth) / 2, CANVAS_HEIGHT - instructionCharHeight - 100);
                    renderStickString(G.instructionsStickString, instructionCharWidth, instructionCharHeight, G.clock - 5, 0.01, 0.2);
                });

                R.font = '20pt ' + monoFont;
                fs('#fff');
                R.textAlign = 'center';

                G.gameRecap.forEach((line, i) => {
                    fillText(line, 1000 / 2, CANVAS_HEIGHT * 3 / 4 - 50 + i * 30);
                });
            });
        });

        // Touch controls
        wrap(() => {
            if (!isTouch) {
                return;
            }

            translate(0, CANVAS_HEIGHT - 200);

            R.globalAlpha = 0.8;
            fs('#000');
            fr(0, 0, 1000, 200);

            fs('#fff');

            translate(0, 100);

            wrap(() => {
                R.globalAlpha = w.down[37] ? 1 : 0.5;

                translate(1000 * 1 / 8, 0);
                rotate(PI);

                G.mobileArrow();
            });

            wrap(() => {
                R.globalAlpha = w.down[39] ? 1 : 0.5;

                translate(1000 * 3 / 8, 0);

                G.mobileArrow();
            });

            wrap(() => {
                R.globalAlpha = w.down[32] ? 1 : 0.5;

                translate(1000 * 5 / 8, 0);

                beginPath();
                moveTo(0, 0);
                arc(0, 0, 80 / 2, 0, TWO_PI);
                fill();
            });

            wrap(() => {
                R.globalAlpha = w.down[38] ? 1 : 0.5;

                translate(1000 * 7 / 8, 0);
                rotate(-PI / 2);

                G.mobileArrow();
            });
        });

        // if (true) {
        //     wrap(() => {
        //         R.font = '10pt ' + monoFont;
        //         fs('#fff');
        //
        //         let info = [
        //             'fps: ' + G.fps,
        //             'planets: ' + G.renderedPlanets,
        //             'stars: ' + G.renderedStars,
        //             'orbits: ' + G.renderedOrbits,
        //             'asteroids: ' + G.renderedAsteroids,
        //             'ships: ' + G.renderedShips,
        //             'particles: ' + G.renderedParticles
        //         ];
        //         let y = 20;
        //         info.forEach(info => {
        //             fillText(info, 1000 - 200, y);
        //             y += 20;
        //         });
        //     });
        // }
    }

    mobileArrow() {
        beginPath();
        moveTo(80 / 2, 0);
        lineTo(-80 / 2, -80 / 2);
        lineTo(-80 / 2, 80 / 2);
        fill();
    }

    showPrompt(promptText, options) {
        G.promptText = promptText && promptText.call ? promptText : () => promptText;
        G.promptClock = G.clock;
        G.promptOptions = options || [];
        G.selectedPromptOption = 0;

        if (G.promptText()) {
            promptSound();
        }
    }

    selectPromptOption(characterOrIndex) {
        let actualText = G.currentPromptText();
        if (actualText.length < (G.promptText() || '').length || G.selectedPromptOption) {
            return;
        }

        (G.promptOptions || []).forEach((option, i) => {
            if (i == characterOrIndex || option.label[0].toLowerCase() === characterOrIndex) {
                G.selectedPromptOption = option;
                setTimeout(option.action, 500); // add a short delay so we can show that the option was selected
                selectSound();
            }
        });
    }

    showMessage(message) {
        G.message = stickString(message);
        interp(G, 'messageProgress', G.message.segments.length, 0, G.message.segments.length * 0.1, 3);
        interp(G, 'messageProgress', 0, G.message.segments.length, G.message.segments.length * 0.1);

        findSytemSound();
    }

    promptRandomMission() {
        // Missions only come from the closest planet
        let planet = U.bodies
            .filter(body => body.orbitsAround)
            .reduce((closest, body) => !closest || dist(U.playerShip, body) < dist(U.playerShip, closest) ? body : closest, null);

        if (planet && !G.missionStep) {
            // Pick another planet that's not too far yet not too close
            let close = body => between(1000, dist(body, planet), 10000);
            let otherPlanets = () => U.bodies.filter(body => body.orbitsAround).filter(close);
            let otherPlanetAndStars = () => otherPlanets().concat(U.stars.filter(close));

            let missionStep = pick([
                new AttackPlanet(pick(otherPlanets())),
                new StudyBody(pick(otherPlanetAndStars())),
                new CollectResources(),
                new Asteroids(),
                new Pirates()
            ]);
            missionStep.civilization = planet.civilization;

            G.proceedToMissionStep(new PromptMission(missionStep));

            for (let i = 0, d = max(planet.radius, dist(U.playerShip, planet) - V.visibleWidth) ; d < dist(U.playerShip, planet) ; i++, d += 50) {
                let angle = angleBetween(planet, U.playerShip);
                // let particle = {
                //     'alpha': 0,
                //     'render': () => wrap()
                // };
                // U.particles.push(particle);

                particle(0, [
                    ['alpha', 1, 0, 0.1, i * 0.02 + 0.2],
                    ['alpha', 0, 1, 0.1, i * 0.02]
                ], particle => {
                    R.strokeStyle = '#fff';
                    R.lineWidth = 2;
                    R.globalAlpha = particle.alpha;
                    beginPath();
                    arc(planet.x, planet.y, d, angle - PI / 16, angle + PI / 16);
                    stroke();
                });
            }
        }

    }

    // Prompt a mission specifically for a given planet (used when player clicks the offer icon)
    promptMissionFromPlanet(planet) {
        try {
            if (!planet || !planet.civilization || G.missionStep) return;

            // Choose a mission similar to promptRandomMission but anchored to the clicked planet
            let close = body => between(1000, dist(body, planet), 10000);
            let otherPlanets = () => U.bodies.filter(body => body.orbitsAround).filter(close);
            let otherPlanetAndStars = () => otherPlanets().concat(U.stars.filter(close));

            let missionStep = pick([
                new AttackPlanet(pick(otherPlanets())),
                new StudyBody(pick(otherPlanetAndStars())),
                new CollectResources(),
                new Asteroids(),
                new Pirates()
            ]);
            missionStep.civilization = planet.civilization;

            G.proceedToMissionStep(new PromptMission(missionStep));
        } catch (e) { /* ignore */ }
    }

    missionDone(success) {
        let missionStep = G.missionStep;
        G.proceedToMissionStep();

        // Update reputation in addition to relationship: +100 on success, -100 on failure
        try {
            if (missionStep && missionStep.civilization && typeof missionStep.civilization.reputation === 'number') {
                missionStep.civilization.reputation += success ? 100 : -100;
                // Apply the reputation mapping so a large reputation change can flip ally/enemy state
                if (typeof missionStep.civilization.applyReputationToRelationship === 'function') {
                    missionStep.civilization.applyReputationToRelationship();
                }
            }
        } catch (e) {}

        // Persist state after reputation/relationship changes
        try { if (typeof U !== 'undefined' && typeof U.saveState === 'function') U.saveState(); } catch (e) {}

        // Also apply the standard relationship delta from mission outcome
        missionStep.civilization.updateRelationship(success ? 0.5 : -0.2);

        G.showPrompt('Mission ' + (success ? 'SUCCESS' : 'FAILED') + '. ' + missionStep.civilization.center.name + ' will remember that.', [{
            'label': dismiss,
            'action': () => G.showPrompt()
        }]);
    }

    start() {
        if (G.started || !G.startable) {
            return;
        }

        U.createPlayerShip();

        // Ensure some planet offers exist when the player starts
        try {
            if (typeof U !== 'undefined' && typeof U.refreshOffers === 'function') {
                U.refreshOffers();
                U.offerRefreshTimer = 600;
            }
        } catch (e) { /* ignore */ }

        interp(G, 'titleYOffset', 0, -CANVAS_HEIGHT, 0.3);

        if (!G.startedOnce) {
            V.zoomScale = V.targetScaleOverride = 1;
            setTimeout(() => G.proceedToMissionStep(new InstructionsStep()), 100);
        }

    // Increase mission cadence baseline for less frequent incoming communications
    G.nextMission = G.startedOnce ? 200 : 90;
        G.started = G.startedOnce = 1;

        introSound();
    }

    
    handlePlayerDeath() {
        G.lives--;
        
        if (G.lives <= 0) {
            G.gameOver();
        } else {
            // Store death location for respawn
            const deathX = U.playerShip.x;
            const deathY = U.playerShip.y;
            
            // Respawn after a delay
            setTimeout(() => {
                U.createPlayerShip();
                U.playerShip.x = deathX + rnd(-200, 200);
                U.playerShip.y = deathY + rnd(-200, 200);
                U.playerShip.health = 1;
                U.playerShip.shield = 1;
            }, 1000);
        }
    }

    renderLives() {
        // Render life icons in upper right corner
        for (let i = 0; i < G.lives; i++) {
            wrap(() => {
                translate(CANVAS_WIDTH - 60 - (i * 50), 60);
                scale(1.2, 1.2);
                
                // Draw ship icon for each life
                fs('#fff');
                R.lineWidth = 3;
                beginPath();
                moveTo(0, -12);
                lineTo(-10, 12);
                lineTo(0, 6);
                lineTo(10, 12);
                closePath();
                fill();
                stroke();
            });
        }
    }

    gameOver() {
        let civilizations = U.bodies
            .filter(body => body.civilization && body.civilization.relationshipType() != body.civilization.initialRelationship)
            .map(body => body.civilization);

        let enemiesMade = civilizations.filter(civilization => civilization.relationshipType() == '#f00').length;
        let alliesMade = civilizations.filter(civilization => civilization.relationshipType() == '#0f0').length;

        let subtitle;
        if (enemiesMade + alliesMade < 10) {
            subtitle = 'you were barely noticed';
        } else if (abs(enemiesMade - alliesMade) < 5) {
            subtitle = 'little has changed';
        } else if (enemiesMade > alliesMade) {
            subtitle = 'you brought war';
        } else {
            subtitle = 'you brought peace';
        }

        G.titleStickString = stickString('game over');
        G.subtitleStickString = stickString(subtitle);
        G.instructionsStickString = stickString('press enter to send another ship');

        G.subtitleCharWidth = 25;
        G.subtitleCharHeight = 50;
        G.subtitleCharThickness = 6;

        G.startable = G.started = 0;

        G.clock = 0;

        interp(G, 'titleYOffset', -CANVAS_HEIGHT, 0, 0.3, 0, 0, () => G.setupNewGame());

        setTimeout(() => {
            G.gameRecap = [
                enemiesMade + ' planets have declared war against you',
                alliesMade + ' species have become your allies'
            ];
            G.startable = 1;
        }, 4000);
    }

    setupNewGame() {
        G.eventHub = new EventHub();

        G.promptText = () => 0;

        G.started = 0;

        G.titleYOffset = 0;

        G.missionStep = 0;
        G.currentWarning = 0;

        G.gameRecap = [];
        // Clear any persisted save when starting a fresh new game so reputation, credits, and other
        // global state are reset. Upgrades will still be persisted for respawn via localStorage
        // but a deliberate New Game should wipe saved state.
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.removeItem('ss_save_v1');
                try { console.debug('setupNewGame: cleared persistent save'); } catch (e) {}
            }
        } catch (e) { /* ignore */ }
    }

    currentPromptText() {
        let promptText = G.promptText() || '';
        let length = ~~min((G.clock - G.promptClock) * 20, promptText.length);
        return promptText.slice(0, length) + (length < promptText.length || (G.clock % 1) > 0.5 ? '_' : '');
    }

}

onload = () => {
    onresize(); // trigger initial sizing pass

    let can = document.querySelector('canvas');
    can.width = 1000;
    can.height = CANVAS_HEIGHT;

    R = can.getContext('2d');

    // Shortcut for all canvas methods to the main canvas
    Object.getOwnPropertyNames(p).forEach(n => {
        if (R[n] && R[n].call) {
            w[n] = p[n].bind(R);
        }
    });

    // Detect available fonts
    R.font = '99pt f'; // Setting a font that obviously doesn't exist
    let reference = measureText(w.title).width;

    for (let fontName of ['Mono', 'Courier']) {
        R.font = '99pt ' + fontName;
        if (measureText(w.title).width != reference) {
            monoFont = fontName;
            break;
        }
    }

    new Game();

    // Start cycle()
    let lf = Date.now();
    let frame = () => {
        let n = Date.now(),
            e = (n - lf) / 1000;

        // if(true){
        //     G.fps = ~~(1 / e);
        // }

        lf = n;

        G.cycle(e);

        requestAnimationFrame(frame);
    };
    frame();

    // Click handling: map canvas clicks to world coordinates and check for planet offer icons
    let canvas = document.querySelector('canvas');
    canvas.addEventListener('click', (ev) => {
        try {
            let rect = canvas.getBoundingClientRect();
            let x = (ev.clientX - rect.left) / rect.width;
            let y = (ev.clientY - rect.top) / rect.height;

            // Convert to world coordinates
            let worldX = (x * 1000 - 1000 / 2) / V.zoomScale + V.x;
            let worldY = (y * CANVAS_HEIGHT - CANVAS_HEIGHT / 2) / V.zoomScale + V.y;

            // Find planets near the click
            let clickedPlanet = null;
            U.bodies.forEach(body => {
                if (body instanceof Planet) {
                    let d = Math.sqrt((body.x - worldX) * (body.x - worldX) + (body.y - worldY) * (body.y - worldY));
                    if (d <= body.radius + 8 && body.hasOffer) {
                        clickedPlanet = body;
                    }
                }
            });

            if (clickedPlanet) {
                // Trigger incoming communication / mission prompt for that planet
                if (G && typeof G.promptMissionFromPlanet === 'function') {
                    G.promptMissionFromPlanet(clickedPlanet);
                }
            }
        } catch (e) { /* ignore click errors */ }
    });
};


</script>
